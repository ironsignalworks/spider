<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>SPIDER STRIKE</title>
<!-- Social and SEO metadata -->
<meta name="description" content="Spider Strike — deploy sticky webs, snare swarms, and protect the nest in a fast arcade defense.">
<meta name="theme-color" content="#ff8c00">
<!-- Open Graph -->
<meta property="og:type" content="website">
<meta property="og:title" content="SPIDER STRIKE">
<meta property="og:description" content="Deploy webs. Snare the swarm. Protect the nest.">
<meta property="og:image" content="card.jpg">
<!-- Twitter Card -->
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:title" content="SPIDER STRIKE">
<meta name="twitter:description" content="Deploy webs. Snare the swarm. Protect the nest.">
<meta name="twitter:image" content="card.jpg">
<link rel="image_src" href="card.jpg">
<style>
  @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
  @font-face{
    font-family:'Still Time';
    src:url('still_time/Still Time.otf') format('opentype');
    font-display:swap;
  }
  
  :root{
    --bg:#0c0602; --ink:#d6f0ff; --muted:#ffd9aa;
    --neon:#ff8c00; --ok:#ff8c00; --warn:#ffb84d; --bad:#cc5500;
    --grid:#2a1100;
  }
  *{box-sizing:border-box}
  
  html,body{
    height:100%;width:100%;margin:0;padding:0;background:#000;
    color:var(--ink);font-family:'VT323',monospace;font-size:20px;
    image-rendering:pixelated;image-rendering:crisp-edges;overflow:hidden;
  }
  
  .wrap{
    position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto;
    background:linear-gradient(180deg, #0b0500 0%, #1a0e00 100%);
    border:4px solid var(--neon);box-shadow:inset 0 0 80px #ff8c0040;
  }
  
  .wrap::before {
    content:"";position:absolute;inset:0;
    background:repeating-linear-gradient(0deg,rgba(0,0,0,0.15),rgba(0,0,0,0.15) 1px,transparent 1px,transparent 2px);
    pointer-events:none;z-index:1000;animation:scanline 8s linear infinite;
  }
  
  @keyframes scanline {
    0%{transform:translateY(0)} 100%{transform:translateY(4px)}
  }
  
  @keyframes flicker {
    0%,100%{opacity:1} 50%{opacity:0.96}
  }
  
  header,footer{
    display:flex;align-items:center;gap:.6rem;padding:.5rem 1rem;
    background:#000;border:3px solid var(--neon);text-shadow:0 0 8px currentColor;
  }
  
  header{justify-content:space-between;user-select:none;animation:flicker 0.15s infinite;}
  
  .brand{
    letter-spacing:.08em;font-size:1.6em;color:var(--neon);
    text-shadow:0 0 10px var(--neon),0 0 20px var(--neon),2px 2px 0 #000;
    font-family:'Still Time','VT323',monospace;
  }
  
  .hud{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;}
  
  .pill{
    padding:.3rem .6rem;border:2px solid var(--ok);background:#000;font-size:1em;
    color:var(--ok);text-shadow:0 0 6px var(--ok);box-shadow:inset 0 0 8px #ff8c0040;
    position:relative;transition:transform 0.1s;
  }
  
  .btn{
    appearance:none;border:3px solid var(--neon);background:#000;color:var(--neon);
    padding:.3rem .7rem;cursor:pointer;font-family:'VT323',monospace;font-size:1em;
    text-shadow:0 0 6px var(--neon);transition:all 0.1s;
  }
  
  .btn:hover{background:var(--neon);color:#000;box-shadow:0 0 20px var(--neon);}
  .btn:active{transform:scale(0.95);}
  
  #gameContainer{position:relative;width:100%;height:100%;overflow:hidden;}
  
  canvas{
    display:block;width:100%;height:100%;image-rendering:pixelated;
        image-rendering:crisp-edges;cursor:crosshair;filter:contrast(1.1);
  }

  /* Mobile layout tweaks */
  @media (max-width: 600px){
    html,body{font-size:16px}
    .wrap{border-width:3px}
    header,footer{padding:.4rem .6rem;border-width:2px}
    .brand{font-size:1.3em;letter-spacing:.06em;text-align:center}
    header{flex-direction:column;align-items:stretch;gap:.4rem}
    .hud{justify-content:center;flex-wrap:wrap;gap:.3rem}
    .pill{font-size:.9em;padding:.2rem .4rem}
    .btn{font-size:.9em;padding:.22rem .48rem}
    .charge{width:60px;height:6px}
    .soundToggle{font-size:.75em;padding:.18rem .4rem}
    footer{font-size:.85em;text-align:center}
    .footerCenter{display:none}
  }
  }
  
  footer{justify-content:center;color:var(--ink);font-size:1em;user-select:none;}
  .footerCenter{flex:1;text-align:center}
  .ironSig{color:var(--muted);text-decoration:none;font-size:.95em}
  .ironSig:hover{color:var(--ok);text-shadow:0 0 8px var(--ok)}
  
  .overlay{
    position:absolute;inset:0;display:none;place-items:center;
    background:radial-gradient(circle,#00000090,#000000e0);z-index:999;
  }
  
  .card{
    background:#000;border:4px solid var(--neon);
    box-shadow:0 0 40px var(--neon), inset 0 0 20px #ff8c0040;
    padding:20px 25px;max-width:min(92vw,620px);text-align:center;
  }
  
  .card h2{
    margin:.2rem 0 0;font-size:2em;letter-spacing:.12em;color:var(--neon);
    text-shadow:0 0 10px var(--neon),0 0 20px var(--neon);
    font-family:'Still Time','VT323',monospace;
  }
  
  .card p{margin:.8rem 0 1.2rem;color:var(--ok);line-height:1.4;}
  
  .kbd{
    border:2px solid var(--ok);background:#000;padding:.3rem .5rem;
    color:var(--ok);text-shadow:0 0 6px var(--ok);
  }
  
  .nukeBtn{
    padding:.3rem .7rem;border-color:var(--warn);color:var(--warn);
    text-shadow:0 0 6px var(--warn);
  }

  .nukeBtn:hover{background:var(--warn);color:#000;box-shadow:0 0 20px var(--warn);}

  /* Flashing style when nuke is ready */
  .nukeBtn.nukeReady{
    animation:bannerFlash 0.7s steps(2, start) infinite;
    box-shadow:0 0 18px var(--warn), inset 0 0 12px #ffb84d40;
    border-color:#ff6688; color:#ff6688; text-shadow:0 0 10px #ff6688;
  }
  
  .charge{
    width:72px;height:8px;background:#001100;border:2px solid var(--ok);overflow:hidden;
  }
  
  .charge>i{
    display:block;height:100%;background:var(--warn);box-shadow:0 0 8px var(--warn);width:0%;
  }
  
  .small{font-size:.9em;color:var(--muted);}
  
  .flyingScore{
    position:absolute;font-family:'VT323',monospace;font-size:32px;
    color:#ff66cc;
    text-shadow:0 0 12px #ff66cc,0 0 24px #ff66cc,0 0 36px #ffd166;
    pointer-events:none;z-index:100;font-weight:bold;
    animation:fsPulse 0.7s ease-in-out infinite alternate;
  }

  @keyframes fsPulse{
    0%{ transform:scale(1); filter:brightness(1); }
    100%{ transform:scale(1.15); filter:brightness(1.2); }
  }

  /* Score pill glow + sparks on collection */
  .scoreGlow{
    box-shadow:0 0 22px #ff66cc,0 0 12px #ffd166, inset 0 0 10px #ff66cc40;
    filter:brightness(1.2) saturate(1.2);
  }
  .scoreSpark{
    position:absolute;width:6px;height:6px;border-radius:50%;
    background:radial-gradient(circle,#ffd166 0%, #ff66cc 60%, transparent 70%);
    pointer-events:none;z-index:101;
    animation:spark 600ms ease-out forwards;
  }
  @keyframes spark{
    0%{ opacity:1; transform:translate(0,0) scale(1); }
    100%{ opacity:0; transform:translate(var(--dx), var(--dy)) scale(0.2); }
  }

  /* Flying heal (HP collection) */
  .flyingHeal{
    position:absolute;font-family:'VT323',monospace;font-size:30px;
    color:#ff3344;
    text-shadow:0 0 10px #ff3344,0 0 20px #ff7788;
    pointer-events:none;z-index:100;font-weight:bold;
    animation:fsPulse 0.7s ease-in-out infinite alternate;
  }
  .lifeGlow{
    box-shadow:0 0 22px #ff3344,0 0 12px #ff7788, inset 0 0 10px #ff334440;
    filter:brightness(1.2) saturate(1.2);
  }
  .healSpark{
    position:absolute;width:6px;height:6px;border-radius:50%;
    background:radial-gradient(circle,#ff7788 0%, #ff3344 60%, transparent 70%);
    pointer-events:none;z-index:101;
    animation:spark 600ms ease-out forwards;
  }
  
  .soundToggle{
    z-index:1;
    padding:.22rem .48rem;border:2px solid var(--ok);background:#000;
    color:var(--ok);font-family:'VT323',monospace;font-size:.85em;
    cursor:pointer;text-shadow:0 0 6px var(--ok);
    margin-left:auto;
  }
  
  .soundToggle:hover{background:var(--ok);color:#000;}
  
  body::after{
    content:"";position:fixed;inset:0;
    background:radial-gradient(ellipse at center,transparent 0%,rgba(0,0,0,0.3) 100%);
    pointer-events:none;z-index:999;
  }

  /* Nuke Ready Banner */
  .nukeBanner{
    position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);
    padding:.4rem .8rem;border:4px solid #ff3366;background:#000;
    color:#ff3366;text-shadow:0 0 10px #ff3366,0 0 20px #ff3366;
    box-shadow:0 0 30px #ff3366, inset 0 0 14px #ff336640;
    font-family:'Still Time','VT323',monospace;letter-spacing:.1em;
    z-index:1100;pointer-events:none;display:none;
    animation:bannerFlash 0.7s steps(2, start) infinite;
    text-align:center;
  }
  .nukeBanner .nbTitle{font-size:2.0em;line-height:1;margin-bottom:.12em;white-space:nowrap}
  .nukeBanner .nbHint{font-size:1.0em;line-height:1;color:#ff99aa;font-family:'VT323',monospace}
  @keyframes bannerFlash{0%{opacity:1;filter:brightness(1.2)}50%{opacity:.3;filter:brightness(.9)}100%{opacity:1;filter:brightness(1.2)}}
</style>
</head>
<body>
<div class="wrap">
    <header>
    <div class="brand">SPIDER STRIKE</div>
    <div class="hud">
      <div class="pill" id="scorePill">Score: <span id="score">0</span></div>
      <div class="pill" id="livesPill">Health: <span id="lives">10</span></div>
      <div class="pill">Silk: <span id="silk">50</span></div>
      
      <div class="pill">Wave: <span id="wave">1</span></div>
      <div class="pill">Speed: <span id="speed">1x</span></div>
      <div class="pill small" style="display:flex;flex-direction:column;align-items:center;padding:.2rem .5rem">
        <div style="font-size:.8rem">NUKE</div>
        <div class="charge"><i id="chargeBar"></i></div>
      </div>
      <button id="restart" class="btn">Restart</button>
      <button id="nukeBtn" class="btn nukeBtn" disabled>Nuke</button>
    </div>
  </header>

  <div id="gameContainer"><canvas id="game"></canvas></div>
  <div id="nukeBanner" class="nukeBanner" aria-live="polite">
    <div class="nbTitle">NUKE 'EM HIGH!</div>
    <div class="nbHint">[PRESS N]</div>
  </div>

  <footer>
    <a class="ironSig" href="https://ironsignalworks.com" target="_blank" rel="noopener">IRON SIGNAL WORKS</a>
    <span class="footerCenter">| CLICK TO DEPLOY WEB NODES | [R]ESTART | [N]UKE | [+]/[-]SPEED |</span>
    <button id="soundToggle" class="soundToggle">SFX ON</button>
  </footer>
  

  <div id="overlay" class="overlay">
    <div class="card">
      <h2 id="ovTitle">SPIDER STRIKE</h2>
      <p id="ovMsg" class="small">
        THE NEST IS UNDER ATTACK!<br>
        DEPLOY WEB NODES TO SLOW ENEMIES<br>
        EACH WEB COSTS <b>15 SILK</b><br>
        NODES WEAR DOWN WITH TRAFFIC<br>
        ENEMIES DIE IF STUCK TOO LONG<br>
        SOME RESIST WEBS - SOME RESIST NUKES<br>
        <br>
        <b>CONTROLS</b><br>
        CLICK: DEPLOY WEB NODE<br>
        R: RESTART RUN<br>
        N: NUKE (WHEN CHARGED)<br>
        + / -: CHANGE GAME SPEED
      </p>
      
      <div style="display:flex;gap:.6rem;justify-content:center">
        <button id="startBtn" class="btn">START</button>
        <button id="howBtn" class="btn">INFO</button>
      </div>
    </div>
  </div>
</div>



<script>
(() => {
  "use strict";
  const DPR = (window.devicePixelRatio || 1);
  // Light haptics for mobile (ignored on desktop)
  function isMobile(){
    try{
      return (navigator.maxTouchPoints && navigator.maxTouchPoints > 0) ||
             (window.matchMedia && matchMedia('(pointer:coarse)').matches);
    }catch(e){ return false; }
  }
  function vibrateLight(){ if ('vibrate' in navigator && isMobile()) try{ navigator.vibrate(18); }catch(e){} }
  function vibrateHit(intensity=1){
    if (!('vibrate' in navigator) || !isMobile()) return;
    const base = Math.max(20, Math.min(60, 30 * intensity));
    try{ navigator.vibrate([base, 40, base]); }catch(e){}
  }
  // Feature flag to enable/disable boss encounters
  const ENABLE_BOSSES = false;

  // Sprite crispness helpers (pixel-snapped, nearest-neighbor)
  function drawSpriteCrisp(img, sx, sy, sw, sh, dx, dy, dw, dh) {
    dx = (dx + 0.5)|0; dy = (dy + 0.5)|0; // snap destination
    dw = dw|0; dh = dh|0;                 // integer size
    ctx.drawImage(img, sx|0, sy|0, sw|0, sh|0, dx, dy, dw, dh);
  }
  
  /*** SPIDER SPRITE ***/
  const SPIDER_SVG_DATAURI =
    'data:image/svg+xml;utf8,' +
    encodeURIComponent(`<?xml version="1.0" encoding="UTF-8"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#ffd000;stroke-width:1.8;stroke-linecap:round;stroke-linejoin:round}
      .s{fill:#0c0c12;stroke:#ffd000;stroke-width:1.2}
      .g{fill:rgba(255,208,0,0.12)}
      .w{stroke:rgba(255,255,255,0.35);stroke-width:1;stroke-linecap:round}
    </style>
  </defs>

  <!-- FRAME 0 (x:0..31) -->
  <g transform="translate(0,0)">
    <!-- soft glow -->
    <circle cx="16" cy="16" r="7" class="g"/>
    <!-- abdomen + cephalothorax -->
    <ellipse cx="16" cy="16" rx="7" ry="5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3.5" ry="3" class="o"/>

    <!-- legs left -->
    <path d="M13 14 C5 10, 5 22, 10 22" class="o"/>
    <path d="M13 18 C6 16, 6 24, 11 24" class="o"/>
    <path d="M14 12 C7 8, 7 14, 10 16" class="o"/>
    <!-- legs right -->
    <path d="M19 14 C27 10, 27 22, 22 22" class="o"/>
    <path d="M19 18 C26 16, 26 24, 21 24" class="o"/>
    <path d="M18 12 C25 8, 25 14, 22 16" class="o"/>

    <!-- little fangs highlight -->
    <path d="M10 16 l-2 1" class="w"/>
    <path d="M10 16 l-2 -1" class="w"/>
  </g>

  <!-- FRAME 1 (x:32..63) -->
  <g transform="translate(32,0)">
    <!-- soft glow -->
    <circle cx="16" cy="16" r="7" class="g"/>
    <!-- abdomen + cephalothorax -->
    <ellipse cx="16" cy="16" rx="7" ry="5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3.5" ry="3" class="o"/>

    <!-- legs shifted (crawl) -->
    <!-- legs left -->
    <path d="M13 14 C6 9, 6 15, 9 17" class="o"/>
    <path d="M13 18 C5 20, 6 26, 12 25" class="o"/>
    <path d="M14 12 C8 10, 6 12, 9 14" class="o"/>
    <!-- legs right -->
    <path d="M19 14 C26 9, 26 15, 23 17" class="o"/>
    <path d="M19 18 C27 20, 26 26, 20 25" class="o"/>
    <path d="M18 12 C24 10, 26 12, 23 14" class="o"/>

    <!-- little fangs highlight -->
    <path d="M10 16 l-2 1" class="w"/>
    <path d="M10 16 l-2 -1" class="w"/>
  </g>
</svg>`);

  const spiderImg = new Image();
  spiderImg.decoding = 'async';
  spiderImg.src = SPIDER_SVG_DATAURI;

  // Spider animation state
  const spiderAnim = { t: 0, frame: 0, w: 32, h: 32, speedMs: 140 };

  function drawSpiderSprite(ctx, x, y, scale = 1) {
    // advance animation (toggle frames every speedMs)
    const now = performance.now();
    if (!spiderAnim.t) spiderAnim.t = now;
    if (now - spiderAnim.t > spiderAnim.speedMs) {
      spiderAnim.t = now;
      spiderAnim.frame = (spiderAnim.frame + 1) % 2; // 0 or 1
    }
    const sx = spiderAnim.frame * spiderAnim.w; // source x on sheet
    const sy = 0;

    const dw = spiderAnim.w * scale;
    const dh = spiderAnim.h * scale;
    // draw centered at (x,y)
    ctx.drawImage(
      spiderImg,
      sx, sy, spiderAnim.w, spiderAnim.h,
      Math.round(x - dw/2), Math.round(y - dh/2),
      Math.round(dw), Math.round(dh)
    );
  }

  function flashSpider(ctx, x, y, scale = 0.6) {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.5;
    drawSpiderSprite(ctx, x, y, scale);
    ctx.restore();
  }
  
  /*** ENEMY SPRITES ***/
  function makeDataURI(svg) {
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
  }

  const SPRITE_SHEETS = {
    gnat: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#00e5ff;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .w{fill:rgba(0,229,255,0.16)}
      .g{fill:rgba(0,229,255,0.08)}
    </style>
  </defs>
  <!-- GNAT: tiny flyer with wings -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings -->
    <ellipse cx="14" cy="12" rx="6" ry="3.5" class="w"/>
    <ellipse cx="20" cy="12" rx="6" ry="3.5" class="w"/>
    <!-- body -->
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3" ry="2.5" class="o"/>
    <!-- legs -->
    <path d="M18 18 l 5 4" class="o"/>
    <path d="M14 18 l -5 4" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings flutter -->
    <ellipse cx="13" cy="13" rx="7" ry="3" class="w"/>
    <ellipse cx="21" cy="11.5" rx="5.5" ry="2.8" class="w"/>
    <!-- body -->
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3" ry="2.5" class="o"/>
    <!-- legs alt -->
    <path d="M18 18 l 6 2" class="o"/>
    <path d="M14 18 l -6 2" class="o"/>
  </g>
</svg>`),

    beetle: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#ffd000;stroke-width:1.8;stroke-linecap:round;stroke-linejoin:round}
      .s{fill:#0c0c12;stroke:#ffd000;stroke-width:1.2}
      .g{fill:rgba(255,208,0,0.12)}
    </style>
  </defs>
  <!-- BEETLE: chunky shell, slow, web-resistant -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="9" class="g"/>
    <!-- elytra split -->
    <path d="M10,12 q6,-4 12,0 v8 q-6,4 -12,0 z" class="o"/>
    <line x1="16" y1="12" x2="16" y2="20" class="s"/>
    <!-- head -->
    <ellipse cx="11" cy="16" rx="3" ry="2.6" class="o"/>
    <!-- legs -->
    <path d="M12 13 l -6 2" class="o"/>
    <path d="M12 16 l -6 0" class="o"/>
    <path d="M12 19 l -6 -2" class="o"/>
    <path d="M20 13 l 6 2" class="o"/>
    <path d="M20 16 l 6 0" class="o"/>
    <path d="M20 19 l 6 -2" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="9" class="g"/>
    <!-- elytra sway -->
    <path d="M10,12 q6,-4 12,0 v8 q-6,4 -12,0 z" class="o"/>
    <line x1="16" y1="12" x2="16" y2="20" class="s"/>
    <!-- head -->
    <ellipse cx="11" cy="16" rx="3.2" ry="2.4" class="o"/>
    <!-- legs alt stance -->
    <path d="M12 13 l -5 3" class="o"/>
    <path d="M12 16 l -6 1" class="o"/>
    <path d="M12 19 l -5 -3" class="o"/>
    <path d="M20 13 l 5 3" class="o"/>
    <path d="M20 16 l 6 1" class="o"/>
    <path d="M20 19 l 5 -3" class="o"/>
  </g>
</svg>`),

    roach: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#00e5ff;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .w{fill:rgba(0,229,255,0.16)}
      .g{fill:rgba(0,229,255,0.08)}
    </style>
  </defs>
  <!-- ROACH: long body, antennae, nuke-immune -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <ellipse cx="16" cy="16" rx="9" ry="5" class="g"/>
    <ellipse cx="16" cy="16" rx="8" ry="4.5" class="o"/>
    <ellipse cx="11.8" cy="16" rx="3" ry="2.4" class="o"/>
    <!-- antennae -->
    <path d="M10 15 q -5 -4, -8 -6" class="a"/>
    <path d="M10 17 q -5  4, -8  6" class="a"/>
    <!-- legs -->
    <path d="M12 13 l -6 1" class="o"/>
    <path d="M20 13 l 6 1" class="o"/>
    <path d="M12 19 l -6 -1" class="o"/>
    <path d="M20 19 l 6 -1" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <ellipse cx="16" cy="16" rx="9" ry="5" class="g"/>
    <ellipse cx="16" cy="16" rx="8" ry="4.5" class="o"/>
    <ellipse cx="11.6" cy="16" rx="3" ry="2.4" class="o"/>
    <!-- antennae sway -->
    <path d="M10 15 q -6 -3, -9 -4" class="a"/>
    <path d="M10 17 q -6  3, -9  4" class="a"/>
    <!-- legs alt -->
    <path d="M12 13 l -5 2" class="o"/>
    <path d="M20 13 l 5 2" class="o"/>
    <path d="M12 19 l -5 -2" class="o"/>
    <path d="M20 19 l 5 -2" class="o"/>
  </g>
</svg>`),

    wasp: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#00e5ff;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .w{fill:rgba(0,229,255,0.16)}
      .g{fill:rgba(0,229,255,0.08)}
    </style>
  </defs>
  <!-- WASP: fast, striped abdomen, stinger -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings -->
    <ellipse cx="14" cy="12" rx="6.5" ry="3" class="w"/>
    <ellipse cx="20" cy="12" rx="6.5" ry="3" class="w"/>
    <!-- thorax/abdomen -->
    <ellipse cx="16" cy="16" rx="6.5" ry="4.2" class="o"/>
    <path d="M13 16 h6" class="y"/>
    <path d="M13 18 h6" class="y"/>
    <!-- head -->
    <ellipse cx="11.8" cy="16" rx="2.8" ry="2.4" class="o"/>
    <!-- stinger -->
    <path d="M22 16 l 4 0" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings tilt -->
    <ellipse cx="13" cy="11.5" rx="6.8" ry="2.6" class="w"/>
    <ellipse cx="21" cy="12.5" rx="6.0" ry="2.4" class="w"/>
    <!-- thorax/abdomen -->
    <ellipse cx="16" cy="16" rx="6.5" ry="4.2" class="o"/>
    <path d="M13 16 h6" class="y"/>
    <path d="M13 18 h6" class="y"/>
    <!-- head -->
    <ellipse cx="12.0" cy="16" rx="2.6" ry="2.2" class="o"/>
    <!-- stinger -->
    <path d="M22 16 l 4.5 0" class="o"/>
  </g>
</svg>`),

    medic: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#ff3344;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .g{fill:rgba(255,48,64,0.18)}
    </style>
  </defs>
  <!-- MEDIC BUG: small red bug, 2 frames -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3" ry="2.5" class="o"/>
    <path d="M18 18 l 5 3" class="o"/>
    <path d="M14 18 l -5 3" class="o"/>
  </g>
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.8" cy="16" rx="3" ry="2.5" class="o"/>
    <path d="M18 18 l 6 2" class="o"/>
    <path d="M14 18 l -6 2" class="o"/>
  </g>
    </svg>`),

    moth: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#c0a0ff;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .w{fill:rgba(192,160,255,0.18)}
      .g{fill:rgba(192,160,255,0.10)}
    </style>
  </defs>
  <!-- MOTH: drifting wings -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="9" class="g"/>
    <ellipse cx="12" cy="14" rx="8" ry="5" class="w"/>
    <ellipse cx="20" cy="14" rx="8" ry="5" class="w"/>
    <ellipse cx="16" cy="16" rx="5.6" ry="4" class="o"/>
    <ellipse cx="12.5" cy="16" rx="2.8" ry="2.2" class="o"/>
  </g>
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="9" class="g"/>
    <ellipse cx="12.5" cy="12.5" rx="8.5" ry="4.2" class="w"/>
    <ellipse cx="20.5" cy="15.5" rx="7.5" ry="4.8" class="w"/>
    <ellipse cx="16" cy="16" rx="5.6" ry="4" class="o"/>
    <ellipse cx="12.5" cy="16" rx="2.8" ry="2.2" class="o"/>
  </g>
</svg>`),

    mantis: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#aaff66;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .g{fill:rgba(170,255,102,0.12)}
    </style>
  </defs>
  <!-- MANTIS: fast striker -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <ellipse cx="16" cy="16" rx="6" ry="3.5" class="o"/>
    <path d="M14 14 l -6 -4" class="o"/>
    <path d="M18 14 l 6 -4" class="o"/>
  </g>
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <ellipse cx="16" cy="16" rx="6.2" ry="3.3" class="o"/>
    <path d="M14 18 l -6 -2" class="o"/>
    <path d="M18 18 l 6 -2" class="o"/>
  </g>
</svg>`)
  };

  // Preload enemy sprite images
  const EnemySprites = {};
  for (const [key, uri] of Object.entries(SPRITE_SHEETS)) {
    const img = new Image();
    img.decoding = 'async';
    img.src = uri;
    EnemySprites[key] = img;
  }

  // Enemy animation state (shared across all enemies)
  const EnemyAnim = {
    w: 32, h: 32,
    speedMs: 120,
    last: 0, frame: 0
  };

  function stepEnemyAnim(now) {
    if (!EnemyAnim.last) EnemyAnim.last = now;
    if (now - EnemyAnim.last > EnemyAnim.speedMs) {
      EnemyAnim.last = now;
      EnemyAnim.frame = (EnemyAnim.frame + 1) % 2;
    }
  }

  // Scale by enemy type to match visual size - DOUBLED
  const SCALE_BY_TYPE = {
    gnat: 0.56,
    beetle: 0.64,
    roach: 0.60,
    wasp: 0.60,
    moth: 0.62,
    mantis: 0.62
  };

  function drawEnemySprite(ctx, enemy, scale = 1) {
    const img = EnemySprites[enemy.type?.key || 'gnat'];
    if (!img || !img.complete) {
      // Fallback placeholder if not loaded
      ctx.save();
      ctx.fillStyle = '#1b1b22';
      ctx.strokeStyle = (enemy.type && enemy.type.color) || '#fff';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); 
      ctx.arc(enemy.x, enemy.y, 4, 0, Math.PI*2); 
      ctx.fill(); 
      ctx.stroke();
      ctx.restore();
      return;
    }
    const sx = EnemyAnim.frame * EnemyAnim.w;
    const sy = 0;
    const dw = EnemyAnim.w * scale;
    const dh = EnemyAnim.h * scale;
    ctx.drawImage(
      img, sx, sy, EnemyAnim.w, EnemyAnim.h,
      Math.round(enemy.x - dw/2), Math.round(enemy.y - dh/2),
      Math.round(dw), Math.round(dh)
    );
  }

  // ============ Chunky Boss Sprites (2 frames, 96x96) ============
  (function(){
    const uri = (svg)=>'data:image/svg+xml;utf8,'+encodeURIComponent(svg);
    // Mother Brood
    const BROOD_URI = uri(`<?xml version="1.0"?>
<svg width="192" height="96" viewBox="0 0 192 96" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .out{fill:#0a0b0f;stroke:#0a0b0f;stroke-width:6;stroke-linecap:round;stroke-linejoin:round}
      .in{fill:#0e0f16;stroke:#bf1f3b;stroke-width:3;stroke-linecap:round;stroke-linejoin:round}
      .fill{fill:#161826}
      .glow{fill:rgba(0,255,140,0.16)}
      .vein{stroke:#00ff8c;stroke-width:2;stroke-linecap:round}
      .hi{stroke:rgba(255,255,255,0.28);stroke-width:2;stroke-linecap:round}
      .egg{fill:#15121a;stroke:#bf1f3b;stroke-width:3}
    </style>
  </defs>
  <g transform="translate(0,0)">
    <ellipse cx="48" cy="56" rx="42" ry="24" class="glow"/>
    <g class="out"><ellipse cx="62" cy="54" rx="32" ry="24"/><circle cx="76" cy="64" r="8"/><circle cx="52" cy="66" r="7"/><circle cx="70" cy="46" r="7"/><circle cx="82" cy="52" r="6"/></g>
    <g class="in"><ellipse cx="62" cy="54" rx="32" ry="24" class="fill"/><circle cx="76" cy="64" r="8" class="fill"/><circle cx="52" cy="66" r="7" class="fill"/><circle cx="70" cy="46" r="7" class="fill"/><circle cx="82" cy="52" r="6" class="fill"/></g>
    <path d="M48 54 C 56 50, 64 56, 76 58" class="vein"/>
    <path d="M52 64 C 60 62, 66 64, 72 68" class="vein"/>
    <g class="out"><ellipse cx="36" cy="50" rx="18" ry="13"/><path d="M30 52 l -12 6"/><path d="M30 48 l -12 -6"/></g>
    <g class="in"><ellipse cx="36" cy="50" rx="18" ry="13" class="fill"/><path d="M30 52 l -12 6" class="hi"/><path d="M30 48 l -12 -6" class="hi"/></g>
    <g class="out"><path d="M28 38 L 18 34 L 10 44"/><path d="M28 46 L 14 46 L 8 58"/><path d="M28 58 L 18 66 L 12 80"/>
      <path d="M44 38 L 54 34 L 62 44"/><path d="M44 46 L 58 46 L 64 58"/><path d="M44 58 L 54 66 L 60 80"/></g>
    <g class="in"><path d="M28 38 L 18 34 L 10 44"/><path d="M28 46 L 14 46 L 8 58"/><path d="M28 58 L 18 66 L 12 80"/>
      <path d="M44 38 L 54 34 L 62 44"/><path d="M44 46 L 58 46 L 64 58"/><path d="M44 58 L 54 66 L 60 80"/></g>
  </g>
  <g transform="translate(96,0)">
    <ellipse cx="48" cy="56" rx="42" ry="24" class="glow"/>
    <g class="out"><ellipse cx="63" cy="53" rx="32" ry="23"/><circle cx="77" cy="63" r="8.5"/><circle cx="51" cy="65" r="7.2"/><circle cx="71" cy="45" r="7.2"/><circle cx="83" cy="51" r="6.2"/></g>
    <g class="in"><ellipse cx="63" cy="53" rx="32" ry="23" class="fill"/><circle cx="77" cy="63" r="8.5" class="fill"/><circle cx="51" cy="65" r="7.2" class="fill"/><circle cx="71" cy="45" r="7.2" class="fill"/><circle cx="83" cy="51" r="6.2" class="fill"/></g>
    <path d="M49 53 C 58 49, 66 54, 78 57" class="vein"/>
    <path d="M53 62 C 61 60, 67 62, 73 66" class="vein"/>
    <g class="out"><ellipse cx="37" cy="50" rx="18" ry="13"/><path d="M31 52 l -13 6"/><path d="M31 48 l -13 -6"/></g>
    <g class="in"><ellipse cx="37" cy="50" rx="18" ry="13" class="fill"/><path d="M31 52 l -13 6" class="hi"/><path d="M31 48 l -13 -6" class="hi"/></g>
    <g class="out"><path d="M29 37 L 17 31 L 9 45"/><path d="M29 48 L 13 44 L 7 58"/><path d="M29 59 L 17 67 L 11 81"/>
      <path d="M45 37 L 57 31 L 65 45"/><path d="M45 48 L 61 44 L 67 58"/><path d="M45 59 L 57 67 L 63 81"/></g>
    <g class="in"><path d="M29 37 L 17 31 L 9 45"/><path d="M29 48 L 13 44 L 7 58"/><path d="M29 59 L 17 67 L 11 81"/>
      <path d="M45 37 L 57 31 L 65 45"/><path d="M45 48 L 61 44 L 67 58"/><path d="M45 59 L 57 67 L 63 81"/></g>
  </g>
</svg>`);
    // Harbinger
    const HARB_URI = uri(`<?xml version="1.0"?>
<svg width="192" height="96" viewBox="0 0 192 96" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .out{fill:#0a0b0f;stroke:#0a0b0f;stroke-width:6;stroke-linecap:round;stroke-linejoin:round}
      .in{fill:#0d0f14;stroke:#39ffd1;stroke-width:3;stroke-linecap:round;stroke-linejoin:round}
      .fill{fill:#12151f}
      .glow{fill:rgba(57,255,209,0.16)}
      .rib{stroke:#39ffd1;stroke-width:2}
      .mist{fill:rgba(57,255,209,0.10)}
      .skull{fill:#0d0f14;stroke:#39ffd1;stroke-width:3}
    </style>
  </defs>
  <g transform="translate(0,0)">
    <ellipse cx="48" cy="56" rx="42" ry="24" class="glow"/>
    <g class="out"><ellipse cx="40" cy="50" rx="18" ry="13"/></g>
    <g class="in"><ellipse cx="40" cy="50" rx="18" ry="13" class="fill"/></g>
    <path d="M30 50 h20" class="rib"/><path d="M31 46 h18" class="rib"/><path d="M31 54 h18" class="rib"/>
    <path d="M22 50 q8 -8 16 0 v8 q-8 8 -16 0 z" class="skull"/>
    <g class="out"><ellipse cx="64" cy="58" rx="30" ry="22"/></g>
    <g class="in"><ellipse cx="64" cy="58" rx="30" ry="22" class="fill"/></g>
    <g class="out"><path d="M30 38 L 18 30 L 10 44"/><path d="M28 48 L 14 46 L 8 60"/><path d="M30 60 L 18 70 L 12 84"/>
      <path d="M50 38 L 62 30 L 70 44"/><path d="M52 48 L 66 46 L 72 60"/><path d="M50 60 L 62 70 L 68 84"/></g>
    <g class="in"><path d="M30 38 L 18 30 L 10 44"/><path d="M28 48 L 14 46 L 8 60"/><path d="M30 60 L 18 70 L 12 84"/>
      <path d="M50 38 L 62 30 L 70 44"/><path d="M52 48 L 66 46 L 72 60"/><path d="M50 60 L 62 70 L 68 84"/></g>
    <ellipse cx="48" cy="76" rx="38" ry="10" class="mist"/>
  </g>
  <g transform="translate(96,0)" opacity="0.9">
    <ellipse cx="48" cy="56" rx="42" ry="24" class="glow"/>
    <g class="out"><ellipse cx="41" cy="49" rx="18" ry="13"/></g>
    <g class="in"><ellipse cx="41" cy="49" rx="18" ry="13" class="fill"/></g>
    <path d="M31 49 h20" class="rib"/><path d="M32 45 h18" class="rib"/><path d="M32 53 h18" class="rib"/>
    <path d="M23 49 q8 -8 16 0 v8 q-8 8 -16 0 z" class="skull"/>
    <g class="out"><ellipse cx="65" cy="57" rx="30" ry="22"/></g>
    <g class="in"><ellipse cx="65" cy="57" rx="30" ry="22" class="fill"/></g>
    <g class="out"><path d="M31 37 L 17 28 L 9 44"/><path d="M29 48 L 13 44 L 7 60"/><path d="M31 61 L 17 71 L 11 85"/>
      <path d="M51 37 L 65 28 L 73 44"/><path d="M53 48 L 69 44 L 75 60"/><path d="M51 61 L 65 71 L 71 85"/></g>
    <g class="in"><path d="M31 37 L 17 28 L 9 44"/><path d="M29 48 L 13 44 L 7 60"/><path d="M31 61 L 17 71 L 11 85"/>
      <path d="M51 37 L 65 28 L 73 44"/><path d="M53 48 L 69 44 L 75 60"/><path d="M51 61 L 65 71 L 71 85"/></g>
    <ellipse cx="48" cy="77" rx="38" ry="10" class="mist"/>
  </g>
</svg>`);
    // Black Widow Final
    const WIDOW_URI = uri(`<?xml version="1.0"?>
<svg width="192" height="96" viewBox="0 0 192 96" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .out{fill:#0a0b0f;stroke:#0a0b0f;stroke-width:6;stroke-linecap:round;stroke-linejoin:round}
      .in{fill:#0c0e15;stroke:#e6001a;stroke-width:3;stroke-linecap:round;stroke-linejoin:round}
      .fill{fill:#131621}
      .glow{fill:rgba(230,0,26,0.14)}
      .hg{fill:#e6001a}
      .hi{stroke:rgba(255,255,255,0.28);stroke-width:2;stroke-linecap:round}
    </style>
  </defs>
  <g transform="translate(0,0)">
    <ellipse cx="48" cy="56" rx="42" ry="24" class="glow"/>
    <g class="out"><ellipse cx="62" cy="56" rx="30" ry="22"/></g>
    <g class="in"><ellipse cx="62" cy="56" rx="30" ry="22" class="fill"/></g>
    <path d="M62,48 c 7,3 7,10 0,13 c -7,-3 -7,-10 0,-13 z" class="hg"/>
    <g class="out"><ellipse cx="36" cy="52" rx="17" ry="12"/></g>
    <g class="in"><ellipse cx="36" cy="52" rx="17" ry="12" class="fill"/></g>
    <path d="M30 54 l -12 6" class="hi"/><path d="M30 49 l -12 -6" class="hi"/>
    <g class="out"><path d="M28 40 L 16 34 L 8 48"/><path d="M28 50 L 14 50 L 8 64"/><path d="M28 62 L 18 70 L 12 84"/>
      <path d="M44 40 L 56 34 L 64 48"/><path d="M44 50 L 58 50 L 64 64"/><path d="M44 62 L 54 70 L 60 84"/></g>
    <g class="in"><path d="M28 40 L 16 34 L 8 48"/><path d="M28 50 L 14 50 L 8 64"/><path d="M28 62 L 18 70 L 12 84"/>
      <path d="M44 40 L 56 34 L 64 48"/><path d="M44 50 L 58 50 L 64 64"/><path d="M44 62 L 54 70 L 60 84"/></g>
  </g>
  <g transform="translate(96,0)">
    <ellipse cx="48" cy="56" rx="42" ry="24" class="glow"/>
    <g class="out"><ellipse cx="63" cy="54.5" rx="30" ry="22"/></g>
    <g class="in"><ellipse cx="63" cy="54.5" rx="30" ry="22" class="fill"/></g>
    <path d="M63,47 c 7,3 7,10 0,13 c -7,-3 -7,-10 0,-13 z" class="hg"/>
    <g class="out"><ellipse cx="37" cy="52" rx="17" ry="12"/></g>
    <g class="in"><ellipse cx="37" cy="52" rx="17" ry="12" class="fill"/></g>
    <path d="M31 54 l -13 6" class="hi"/><path d="M31 49 l -13 -6" class="hi"/>
    <g class="out"><path d="M29 39 L 15 31 L 7 47"/><path d="M29 50 L 13 48 L 7 66"/><path d="M29 63 L 17 71 L 11 85"/>
      <path d="M45 39 L 59 31 L 67 47"/><path d="M45 50 L 61 48 L 67 66"/><path d="M45 63 L 57 71 L 63 85"/></g>
    <g class="in"><path d="M29 39 L 15 31 L 7 47"/><path d="M29 50 L 13 48 L 7 66"/><path d="M29 63 L 17 71 L 11 85"/>
      <path d="M45 39 L 59 31 L 67 47"/><path d="M45 50 L 61 48 L 67 66"/><path d="M45 63 L 57 71 L 63 85"/></g>
  </g>
</svg>`);
    const loadImg = (u)=>{ const i=new Image(); i.decoding='async'; i.src=u; return i; };
    const imgs = { brood: loadImg(BROOD_URI), harb: loadImg(HARB_URI), widow: loadImg(WIDOW_URI) };
    const FW=96, FH=96; const Anim={ t:0, f:0, ms:180 };
    function stepBossAnim(now){ if(!Anim.t) Anim.t=now; if(now-Anim.t>Anim.ms){ Anim.t=now; Anim.f=(Anim.f+1)&1; } }
    function drawBossChunk(img, x, y, scale=2){ if(!img.complete) return; const sx=Anim.f*FW; const dw=(FW*scale)|0, dh=(FH*scale)|0; const dx=Math.round(x-dw/2), dy=Math.round(y-dh/2); ctx.imageSmoothingEnabled=false; try{ctx.imageSmoothingQuality='low';}catch(e){} drawSpriteCrisp(img, sx, 0, FW, FH, dx, dy, dw, dh); }
    window.ChunkyBossSprites = { step: stepBossAnim, drawMother:(x,y,s=2)=>drawBossChunk(imgs.brood,x,y,s), drawHarb:(x,y,s=2)=>drawBossChunk(imgs.harb,x,y,s), drawWidow:(x,y,s=2)=>drawBossChunk(imgs.widow,x,y,s), _imgs:imgs };
  })();

  /* ========================= 
     BOSS SYSTEM (3 patterns)
     ========================= */
  const BossKind = { BROOD:'mother_brood', HARB:'harbinger', WIDOW:'black_widow_final' };
  const bossHazards = { acidPools:[], shards:[], snares:[], shockwaves:[] };
  const R = (a,b)=>a+Math.random()*(b-a);
  function webDamagePerSecond(slowMult){ if (slowMult>=0.7) return 0; const t=(0.7-slowMult)/0.7; return 10*t; }
  function sampleWebAt(x,y,dt,applyWear=true){ let slow=1; for(const n of state.nodes){ const dx=x-n.x, dy=y-n.y; const d=Math.hypot(dx,dy); if(d<n.r){ const t=1-(d/n.r); const s=1-(NODE_FADE+(NODE_SLOW-NODE_FADE)*t); slow*=s; if(applyWear){ n.dur -= NODE_DECAY_PER_ENEMY*(dt/1000)*(0.25+0.75*t);} } } return { slowMult: Math.min(1, Math.max(0.12, slow))}; }
  function findNearestNode(x,y){ let best=null,bd=1e9; for(const n of state.nodes){ const d=Math.hypot(x-n.x,y-n.y); if(d<bd){bd=d; best=n;} } return best?{node:best,d:bd}:null; }
  const BossDefs = {
    [BossKind.BROOD]: { name:'Mother Brood', maxHp:900, speed:0.030*DPR, webResist:0.25, nukeMult:0.7,
      attack:{ layLarvaeEvery:2200, dropAcidEvery:3500, acid:{ r:70*DPR, dps:18, life:6000 } } },
    [BossKind.HARB]: { name:'The Harbinger', maxHp:750, speed:0.045*DPR, webResist:0.10, nukeMult:0.5,
      attack:{ phaseEvery:5200, phaseDur:1800, shardEvery:900, shockEvery:5000, shardSpeed:0.35*DPR,
        shock:{ expand:1.2*DPR, max: Math.max(640,480)*0.9, strength:12 } } },
    [BossKind.WIDOW]: { name:'Black Widow — Final', maxHp:600, speed:0.060*DPR, webResist:0.0, nukeMult:1.0,
      attack:{ dashEvery:2400, dashDur:350, dashBoost:2.6, snareEvery:1800, snare:{ r:90*DPR, disableMs:2000, life:2600 } } },
  };
  let boss = null;
  function spawnBoss(kind){ const def=BossDefs[kind]; if(!def) return; const side=Math.floor(Math.random()*4); let x,y; if(side===0){x=Math.random()*canvas.width;y=-120*DPR;} else if(side===1){x=canvas.width+120*DPR;y=Math.random()*canvas.height;} else if(side===2){x=Math.random()*canvas.width;y=canvas.height+120*DPR;} else {x=-120*DPR;y=Math.random()*canvas.height;} boss = { kind, def, x,y, vx:0, vy:0, hp:def.maxHp, t:0, timers:{a:0,b:0,c:0,phase:0,dash:0}, ghost:false, snareLock:0, stuckDmg:0, lastHitNukeTick:0 }; if (sounds.musicEnabled) startBossMusic(); }
  function damageBossFromNuke(){ if(!boss) return; const def=boss.def; if(boss.kind===BossKind.HARB && boss.ghost) return; const est=Math.max(1, Math.floor(state.enemies.length)); const dmg = 80*def.nukeMult + 6*est*def.nukeMult; applyBossDamage(dmg,'nuke'); }
  function applyBossDamage(amount, source){
  if (!boss) return;
  boss.hp = Math.max(0, boss.hp - amount);
  emitBurst(boss.x, boss.y, source==='nuke' ? '#ff7880' : '#ff2136', 18);
  if (boss.hp === 0){
    addScore(150);
    bossHazards.acidPools.length=0;
    bossHazards.shards.length=0;
    bossHazards.snares.length=0;
    bossHazards.shockwaves.length=0;
    state.silk = Math.min(SILK_MAX, state.silk + 60);
    boss = null;
    if (state.running && sounds.musicEnabled) startMusic();
  }
}function updateBoss(dt){ if(!boss) return; const c={x:canvas.width/2,y:canvas.height/2}; boss.t+=dt; let { slowMult } = sampleWebAt(boss.x,boss.y,dt,true); slowMult = slowMult + (1-slowMult)*boss.def.webResist; const dps = webDamagePerSecond(slowMult); if(dps>0 && !(boss.kind===BossKind.HARB && boss.ghost)) applyBossDamage(dps*(dt/1000),'web'); let speed=boss.def.speed;
    if(boss.kind===BossKind.HARB){ boss.timers.phase+=dt; boss.timers.a+=dt; boss.timers.b+=dt; boss.timers.c+=dt; if(!boss.ghost && boss.timers.phase>=boss.def.attack.phaseEvery){ boss.ghost=true; boss.timers.phase=0;} if(boss.ghost && boss.timers.phase>=boss.def.attack.phaseDur){ boss.ghost=false; boss.timers.phase=0;} if(boss.timers.a>=boss.def.attack.shardEvery){ boss.timers.a=0; const near=findNearestNode(boss.x,boss.y); const target=near?.node||c; const ang=Math.atan2(target.y-boss.y,target.x-boss.x)+R(-0.2,0.2); bossHazards.shards.push({x:boss.x,y:boss.y,vx:Math.cos(ang)*boss.def.attack.shardSpeed,vy:Math.sin(ang)*boss.def.attack.shardSpeed,life:0,max:3500}); } if(boss.timers.b>=boss.def.attack.shockEvery){ boss.timers.b=0; bossHazards.shockwaves.push({x:boss.x,y:boss.y,r:0,expand:boss.def.attack.shock.expand,life:0,max:900,strength:boss.def.attack.shock.strength}); } }
    if(boss.kind===BossKind.BROOD){ boss.timers.a+=dt; boss.timers.b+=dt; if(boss.timers.a>=boss.def.attack.layLarvaeEvery){ boss.timers.a=0; for(let i=0;i<3;i++){ const ang=Math.random()*Math.PI*2; const rx=boss.x+Math.cos(ang)*40*DPR, ry=boss.y+Math.sin(ang)*40*DPR; state.enemies.push({ x:rx,y:ry, hp:12, speed:ENEMY_SPEED0*1.5*DPR, slow:1, stuckTimer:0, type:{key:'gnat',color:'#b1b7ff', webResist:0.0, nukeImmune:false, stuckMult:1.0} }); } } if(boss.timers.b>=boss.def.attack.dropAcidEvery){ boss.timers.b=0; bossHazards.acidPools.push({ x:boss.x+R(-40,40)*DPR, y:boss.y+R(-40,40)*DPR, r:boss.def.attack.acid.r, dps:boss.def.attack.acid.dps, life:0, max:boss.def.attack.acid.life }); } }
    if(boss.kind===BossKind.WIDOW){ boss.timers.a+=dt; boss.timers.b+=dt; boss.timers.dash+=dt; let dashBoost=1; if(boss.timers.dash>=boss.def.attack.dashEvery){ boss.timers.dash=0; boss.timers.c=0; } if(boss.timers.c<boss.def.attack.dashDur){ boss.timers.c+=dt; dashBoost=boss.def.attack.dashBoost; } if(boss.timers.b>=boss.def.attack.snareEvery){ boss.timers.b=0; bossHazards.snares.push({ x:boss.x+R(-20,20)*DPR, y:boss.y+R(-20,20)*DPR, r:boss.def.attack.snare.r, disableMs:boss.def.attack.snare.disableMs, life:0, max:boss.def.attack.snare.life }); } speed*=dashBoost; }
    const moveSlow = (boss.kind===BossKind.HARB && boss.ghost)?1:slowMult; const vx=c.x-boss.x, vy=c.y-boss.y; const dist=Math.hypot(vx,vy)||1; const ux=vx/dist, uy=vy/dist; const step=speed*moveSlow*dt; boss.x+=ux*step; boss.y+=uy*step; if(dist<=NEST_R+6*DPR){ damage(2); boss.x-=ux*40*DPR; boss.y-=uy*40*DPR; }
    updateBossHazards(dt);
  }
  function updateBossHazards(dt){ for(let i=bossHazards.acidPools.length-1;i>=0;i--){ const a=bossHazards.acidPools[i]; a.life+=dt; for(const n of state.nodes){ const d=Math.hypot(a.x-n.x, a.y-n.y); if(d<a.r){ n.dur -= a.dps*(dt/1000); } } if(a.life>=a.max) bossHazards.acidPools.splice(i,1); }
    for(let i=bossHazards.shards.length-1;i>=0;i--){ const s=bossHazards.shards[i]; s.life+=dt; s.x+=s.vx*dt; s.y+=s.vy*dt; const near=findNearestNode(s.x,s.y); if(near && near.d<18*DPR){ near.node.dur-=35; emitBurst(s.x,s.y,'#39ffd1',10); bossHazards.shards.splice(i,1); continue; } const dc=Math.hypot(s.x-canvas.width/2,s.y-canvas.height/2); if(dc<NEST_R){ damage(1); bossHazards.shards.splice(i,1); continue;} if(s.life>=s.max) bossHazards.shards.splice(i,1); }
    for(let i=bossHazards.snares.length-1;i>=0;i--){ const sn=bossHazards.snares[i]; sn.life+=dt; for(const n of state.nodes){ const d=Math.hypot(sn.x-n.x, sn.y-n.y); if(d<sn.r){ if(!n._snareLeft) n._snareLeft=sn.disableMs; n._snareLeft = Math.max(n._snareLeft, sn.disableMs); } } if(sn.life>=sn.max) bossHazards.snares.splice(i,1); }
    for(let i=bossHazards.shockwaves.length-1;i>=0;i--){ const w=bossHazards.shockwaves[i]; w.life+=dt; w.r+=w.expand*dt; for(const n of state.nodes){ const d=Math.hypot(w.x-n.x, w.y-n.y); if(Math.abs(d-w.r)<16*DPR){ n.dur -= w.strength*(dt/1000)*50; } } if(w.r>w.max || w.life>=w.max) bossHazards.shockwaves.splice(i,1); }
    for(const n of state.nodes){ if(n._snareLeft && n._snareLeft>0){ n._snareLeft-=dt; n._origR=n._origR||n.r; n.r = Math.max(8*DPR, n._origR*0.12); if(n._snareLeft<=0){ n.r=n._origR||n.r; n._origR=null; n._snareLeft=0; } } }
  }
  function drawBoss(ctx){ if(!boss) return; ChunkyBossSprites.step(performance.now()); if(boss.kind===BossKind.BROOD){ ChunkyBossSprites.drawMother(boss.x,boss.y,2); } else if(boss.kind===BossKind.HARB){ if (boss.ghost){ ctx.save(); ctx.globalAlpha = 0.7; } ChunkyBossSprites.drawHarb(boss.x,boss.y,2); if (boss.ghost){ ctx.restore(); } } else { ChunkyBossSprites.drawWidow(boss.x,boss.y,2); }
    const pct=boss.hp/boss.def.maxHp; const w=140*DPR, h=8*DPR, x=boss.x-w/2, y=boss.y-70*DPR; ctx.fillStyle='rgba(0,0,0,0.5)'; ctx.fillRect(x,y,w,h); ctx.fillStyle = pct>0.5?'rgba(61,255,122,0.9)' : (pct>0.25?'rgba(255,216,74,0.95)':'rgba(255,77,77,0.95)'); ctx.fillRect(x,y,w*pct,h); ctx.strokeStyle='rgba(255,255,255,0.3)'; ctx.lineWidth=1; ctx.strokeRect(x,y,w,h);
    for(const a of bossHazards.acidPools){ const g=ctx.createRadialGradient(a.x,a.y,0,a.x,a.y,a.r); g.addColorStop(0,'rgba(0,255,140,0.22)'); g.addColorStop(1,'rgba(0,255,140,0.04)'); ctx.fillStyle=g; ctx.beginPath(); ctx.arc(a.x,a.y,a.r,0,Math.PI*2); ctx.fill(); }
    for(const s of bossHazards.shards){ ctx.strokeStyle='rgba(57,255,209,0.95)'; ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.moveTo(s.x-4*DPR,s.y); ctx.lineTo(s.x+4*DPR,s.y); ctx.stroke(); }
    for(const sn of bossHazards.snares){ ctx.strokeStyle='rgba(255,33,54,0.7)'; ctx.lineWidth=2*DPR; ctx.beginPath(); ctx.arc(sn.x,sn.y,sn.r,0,Math.PI*2); ctx.stroke(); }
    for(const wv of bossHazards.shockwaves){ ctx.strokeStyle='rgba(57,255,209,0.5)'; ctx.lineWidth=3*DPR; ctx.beginPath(); ctx.arc(wv.x,wv.y,wv.r,0,Math.PI*2); ctx.stroke(); }
  }

  // Boss sprite sheet (embedded SVG, two frames side-by-side 128x96)
  function makeDataURI(svg){ return 'data:image/svg+xml;utf8,'+encodeURIComponent(svg); }
  const BOSS_BLACK_WIDOW_URI = makeDataURI(`<?xml version="1.0"?>
<svg width="256" height="96" viewBox="0 0 256 96" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0b0c0f;stroke:#e6001a;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
      .g{fill:rgba(230,0,26,0.14)}
      .s{stroke:#e6001a;stroke-width:1.4;stroke-linecap:round}
      .w{fill:#0b0c0f;stroke:#e6001a;stroke-width:1.4}
      .h{fill:#e6001a}
      .hl{stroke:rgba(255,255,255,0.28);stroke-width:1.2;stroke-linecap:round}
    </style>
  </defs>
  <g transform="translate(0,0)">
    <ellipse cx="64" cy="48" rx="60" ry="42" class="g"/>
    <ellipse cx="78" cy="52" rx="38" ry="27" class="o"/>
    <path d="M78,43 c 6,3 6,9 0,12 c -6,-3 -6,-9 0,-12 z" class="h"/>
    <path d="M50 44 l 16 0" class="t"/>
    <path d="M48 54 l 20 0" class="t"/>
    <path d="M52 64 l 18 0" class="t"/>
    <ellipse cx="48" cy="48" rx="20" ry="14" class="o"/>
    <path d="M46 24 l -4 -10" class="o"/>
    <path d="M50 22 l -3 -12" class="o"/>
    <path d="M54 22 l  0 -11" class="o"/>
    <path d="M58 24 l  3 -10" class="o"/>
    <circle cx="56" cy="58" r="3" class="p"/>
    <circle cx="64" cy="60" r="3" class="p"/>
    <path d="M38 40 C 10 24, 8 50, 22 56" class="o"/>
    <path d="M36 48 C  6 44, 8 70, 26 72" class="o"/>
    <path d="M38 56 C  8 64, 10 88, 30 86" class="o"/>
    <path d="M58 40 C 86 24, 88 50, 74 56" class="o"/>
    <path d="M60 48 C 90 44, 88 70, 70 72" class="o"/>
    <path d="M58 56 C 88 64, 86 88, 66 86" class="o"/>
    <path d="M40 50 l -8 4" class="w"/>
    <path d="M40 46 l -8 -4" class="w"/>
  </g>
  <g transform="translate(128,0)">
    <ellipse cx="64" cy="48" rx="60" ry="42" class="g"/>
    <ellipse cx="79" cy="50.5" rx="38" ry="27" class="o"/>
    <path d="M79,41.5 c 6,3 6,9 0,12 c -6,-3 -6,-9 0,-12 z" class="h"/>
    <path d="M52 45 l 16 0" class="t"/>
    <path d="M50 55 l 20 0" class="t"/>
    <path d="M54 65 l 18 0" class="t"/>
    <ellipse cx="49" cy="48" rx="20" ry="14" class="o"/>
    <path d="M47 24 l -3 -10" class="o"/>
    <path d="M51 22 l -2 -12" class="o"/>
    <path d="M55 22 l  1 -11" class="o"/>
    <path d="M59 24 l  4 -10" class="o"/>
    <circle cx="57" cy="59" r="3" class="p"/>
    <circle cx="65" cy="61" r="3" class="p"/>
    <path d="M39 40 C  8 22,  8 52, 24 58" class="o"/>
    <path d="M37 48 C  6 42, 10 72, 28 73" class="o"/>
    <path d="M39 56 C  8 66, 12 90, 32 88" class="o"/>
    <path d="M59 40 C 90 22, 92 52, 76 58" class="o"/>
    <path d="M61 48 C 92 42, 90 72, 72 73" class="o"/>
    <path d="M59 56 C 90 66, 88 90, 68 88" class="o"/>
    <path d="M41 50 l -9 4" class="w"/>
    <path d="M41 46 l -9 -4" class="w"/>
    <circle cx="36" cy="58" r="2.2" class="f"/>
  </g>
</svg>`);

  const BossWidowImg = new Image();
  BossWidowImg.decoding = 'async';
  BossWidowImg.src = BOSS_BLACK_WIDOW_URI;
  const BW_FRAME_W = 128, BW_FRAME_H = 96;
  const BossWidowAnim = { last: 0, frame: 0, speedMs: 220 };
  function stepBossWidowAnim(now){ if (!BossWidowAnim.last) BossWidowAnim.last=now; if (now-BossWidowAnim.last>BossWidowAnim.speedMs){BossWidowAnim.last=now; BossWidowAnim.frame=(BossWidowAnim.frame+1)%2;} }
  function drawBossWidow(ctx, x, y, scale = 1){
    const sx = BossWidowAnim.frame * BW_FRAME_W;
    const dw = Math.round(BW_FRAME_W * scale);
    const dh = Math.round(BW_FRAME_H * scale);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(BossWidowImg, sx, 0, BW_FRAME_W, BW_FRAME_H,
      Math.round(x - dw/2), Math.round(y - dh/2), dw, dh);
  }
  
  /*** SOUND SYSTEM ***/
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sounds = {
    enabled: true,
    musicEnabled: true,
    sfx: {},
    music: null,
    ext: null,
    musicNode: null,
    musicGain: null
  };

  const AUDIO_PATH = 'assets/audio/';
  const SFX_PATH = AUDIO_PATH + 'sfx/';
  const MUSIC_PATH = AUDIO_PATH + 'music/';
  const SFX_FILES = {
    webDeploy: 'webDeploy',
    enemyKill: 'enemyKill',
    damage: 'damage',
    scorePoint: 'scorePoint',
    scoreCollect: 'scoreCollect',
    nuke: 'nuke',
    waveStart: 'waveStart',
    waveComplete: 'waveComplete',
    nukeCharged: 'nukeCharged',
    gameOver: 'gameOver',
    button: 'button',
    healthUp: 'healthUp'
  };
  const SFX_VOL = {
    webDeploy: 0.35,
    enemyKill: 0.4,
    damage: 0.5,
    scorePoint: 0.25,
    scoreCollect: 0.25,
    nuke: 0.5,
    waveStart: 0.3,
    waveComplete: 0.35,
    nukeCharged: 0.35,
    gameOver: 0.5,
    button: 0.2,
    healthUp: 0.4
  };

  function detectAudioExt(){
    const a = document.createElement('audio');
    if (a.canPlayType('audio/mpeg')) return '.mp3';
    if (a.canPlayType('audio/ogg')) return '.ogg';
    if (a.canPlayType('audio/wav')) return '.wav';
    return '.mp3';
  }

  function loadAllAudio(){
    sounds.ext = detectAudioExt();
    for (const [k, base] of Object.entries(SFX_FILES)){
      const el = new Audio(SFX_PATH + base + sounds.ext);
      el.preload = 'auto';
      el.volume = SFX_VOL[k] ?? 0.35;
      sounds.sfx[k] = el;
    }
  }

  // Resume audio context on user interaction (browser requirement)
  function resumeAudio() {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  // SFX player  uses folder assets/audio; falls back to synth if missing
  function playSound(type) {
    if (!sounds.enabled) return;
    if (!sounds.ext) loadAllAudio();
    // Try folder-based SFX first
    const base = sounds.sfx && sounds.sfx[type];
    if (base) {
      try{
        const a = base.cloneNode();
        a.volume = base.volume;
        a.play();
        return;
      }catch(e){/* fall back to synth */}
    }

    // Fallback: simple WebAudio beeps
    resumeAudio();
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    switch(type) {
      case 'webDeploy': // Node placement
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
        
      case 'enemyKill': // Enemy destroyed
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        break;
        
      case 'damage': // Player takes damage
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
        break;
        
      case 'scorePoint': // Score flies to board
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
        break;
        
      case 'scoreCollect': // Score reaches board
        osc.frequency.setValueAtTime(1200, now);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
        break;
        
      case 'nuke': // Nuclear explosion
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
        // Add second layer
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(200, now);
        osc2.frequency.exponentialRampToValueAtTime(50, now + 0.4);
        gain2.gain.setValueAtTime(0.2, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc2.start(now);
        osc2.stop(now + 0.5);
        break;
        
      case 'waveStart': // New wave begins
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(500, now + 0.15);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        break;
        
      case 'waveComplete': // Wave cleared
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.start(now);
        osc.stop(now + 0.25);
        break;
        
      case 'nukeCharged': // Nuke ready
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now);
        osc.stop(now + 0.12);
        break;
        
      case 'gameOver': // Death
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.8);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
        osc.start(now);
        osc.stop(now + 1);
        break;
        
      case 'button': // UI button click
        osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
        break;
    }
  }

  // Background music  loads from assets/audio/music/bg.(mp3|ogg|wav)
  // Background music helpers
function playMusic(track){
  if (!sounds.musicEnabled) return;
  if (!sounds.ext) loadAllAudio();
  if (!sounds.music) sounds.music = new Audio();
  try{ sounds.music.pause(); }catch(e){}
  const src = MUSIC_PATH + track + (sounds.ext || '.mp3');
  sounds.music.src = src;
  sounds.music.loop = true;
  sounds.music.volume = track === 'boss' ? 0.28 : 0.25;
  // Fallback to bg if boss track missing
  sounds.music.onerror = () => { if (track !== 'bg') { sounds.music.onerror = null; playMusic('bg'); } };
  try{ sounds.music.play(); }catch(e){}
  sounds.musicNode = sounds.music;
}
function startMusic(){ playMusic('bg'); }
function startBossMusic(){ playMusic('boss'); }function stopMusic() {
    if (sounds.music) { try{ sounds.music.pause(); sounds.music.currentTime = 0; }catch(e){} }
    sounds.musicNode = null;
  }

  // Sound toggle button
  const soundToggle = document.getElementById('soundToggle');
  soundToggle.addEventListener('click', () => {
    sounds.enabled = !sounds.enabled;
    sounds.musicEnabled = !sounds.musicEnabled;
    soundToggle.textContent = sounds.enabled ? 'SFX ON' : 'SFX OFF';
    if (sounds.musicEnabled && state.running) { if (typeof boss !== 'undefined' && boss) startBossMusic(); else startMusic(); } else {
      stopMusic();
    }
    playSound('button');
  });

  /*** CANVAS ***/
  const canvas = document.getElementById('game');
  const gameContainer = document.getElementById('gameContainer');
  const ctx = canvas.getContext('2d', {alpha:false});
  let PIXEL_SCALE = (window.matchMedia && matchMedia('(max-width: 600px)').matches) ? 2 : 3;
  
  function resize(){ 
    const rect = gameContainer.getBoundingClientRect();
    canvas.width = Math.floor(rect.width / PIXEL_SCALE);
    canvas.height = Math.floor(rect.height / PIXEL_SCALE);
  }
  addEventListener('resize', resize, {passive:true}); 
  resize();
  ctx.imageSmoothingEnabled = false;
  try{ ctx.imageSmoothingQuality = 'low'; }catch(e){}

  const mq = (window.matchMedia && matchMedia('(max-width: 600px)'));
  if (mq) {
    const applyScale = () => { PIXEL_SCALE = mq.matches ? 2 : 3; resize(); };
    if (mq.addEventListener) mq.addEventListener('change', applyScale);
    else if (mq.addListener) mq.addListener(applyScale);
  }

  const elScore = document.getElementById('score');
  const elLives = document.getElementById('lives');
  const elSilk = document.getElementById('silk');
  const elWave = document.getElementById('wave');
  const elSpeed = document.getElementById('speed');
  const restartBtn = document.getElementById('restart');
  const chargeBar = document.getElementById('chargeBar');
  const nukeBtn = document.getElementById('nukeBtn');
  const scorePill = document.getElementById('scorePill');
  const livesPill = document.getElementById('livesPill');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovMsg = document.getElementById('ovMsg');
  const startBtn = document.getElementById('startBtn');
  const howBtn = document.getElementById('howBtn');
  
  const nukeBanner = document.getElementById('nukeBanner');

  const CENTER = () => ({x: canvas.width/2, y: canvas.height/2});
  const NEST_R = 10;
  const START_LIVES = 10, START_SILK = 50, SILK_MAX = 240, SILK_REGEN = 6;
  const NODE_COST = 15, NODE_R = 28, NODE_SLOW = 0.55, NODE_FADE = 0.35, NODE_DUR0 = 100, NODE_DECAY_PER_ENEMY = 7;
  const ENEMY_BASE = 8, ENEMY_HP0 = 10, ENEMY_SPEED0 = 0.025;
  const WAVE_GAP_MS = 7000, SPAWN_BURST = 260, SPEEDS = [1, 1.5, 2, 3], STUCK_KILL_MS = 2500;
  const NUKE_CHARGE_MAX = 100, NUKE_SCORE_PER_KILL = 8, NUKE_SILK_PER_KILL = 3;
  // Boss tuning
  const BOSS_SPEED = 0.018, BOSS_STUCK_MULT = 3.5, BOSS_SCORE = 50, BOSS_SILK = 40, BOSS_DAMAGE = 3;
  // Powerup (health bug)
  const POWERUP_HEAL = 2, POWERUP_SPEED = 0.02, POWERUP_INTERVAL_MS = 5000, POWERUP_CHANCE = 1.0;

  const COLORS = {
    bg:'#0c0602', grid:'#b56600', nest:'#ff8c00', nestCore:'#000',
    node:'#ff8c00', nodeDim:'#804400', web:'#ff8c0040', particle:'#00ff66'
  };

  // Best score persistence (localStorage)
  const BEST_KEY = 'spider_best_score';
  function loadBest(){ try{ return Math.max(0, parseInt(localStorage.getItem(BEST_KEY)||'0',10)||0); }catch(e){ return 0; } }
  function saveBest(v){ try{ localStorage.setItem(BEST_KEY, String(v|0)); }catch(e){} }

  const TYPES = [
    {key:'gnat',   name:'GNAT',   color:'#00e5ff', hp:ENEMY_HP0+0,  speed:ENEMY_SPEED0*1.25, webResist:0.00, nukeImmune:false, stuckMult:1.0},
    {key:'beetle', name:'BEETLE', color:'#ffd000', hp:ENEMY_HP0+8,  speed:ENEMY_SPEED0*0.85, webResist:0.60, nukeImmune:false, stuckMult:1.6},
    {key:'roach',  name:'ROACH',  color:'#ff7a00', hp:ENEMY_HP0+4,  speed:ENEMY_SPEED0*1.00, webResist:0.20, nukeImmune:true,  stuckMult:1.2},
    {key:'wasp',   name:'WASP',   color:'#ff3366', hp:ENEMY_HP0+6,  speed:ENEMY_SPEED0*1.35, webResist:0.30, nukeImmune:false, stuckMult:1.1},
    {key:'moth',   name:'MOTH',   color:'#c0a0ff', hp:ENEMY_HP0+5,  speed:ENEMY_SPEED0*0.95, webResist:0.15, nukeImmune:false, stuckMult:1.2},
    {key:'mantis', name:'MANTIS', color:'#aaff66', hp:ENEMY_HP0+2,  speed:ENEMY_SPEED0*1.55, webResist:0.10, nukeImmune:false, stuckMult:1.0}
  ];

  function pickType(wave){
    const wGnat   = Math.max(1, 6 - Math.floor(wave/3));
    const wBeet   = Math.min(5, 1 + Math.floor(wave/4));
    const wRoach  = Math.min(4, Math.floor(wave/5));
    const wWasp   = Math.min(5, Math.floor(wave/3));
    const wMoth   = Math.min(4, 1 + Math.floor(wave/4));
    const wMantis = Math.min(4, Math.floor(wave/5));
    const bag = [
      ...Array(wGnat).fill('gnat'),
      ...Array(wBeet).fill('beetle'),
      ...Array(wRoach).fill('roach'),
      ...Array(wWasp).fill('wasp'),
      ...Array(wMoth).fill('moth'),
      ...Array(wMantis).fill('mantis')
    ];
    const key = bag[Math.floor(Math.random()*bag.length)];
    return TYPES.find(t=>t.key===key) || TYPES[0];
  }

  const state = {
    running:false, t:0, dt:0, last:performance.now(),
    speedIndex:0, score:0, lives:START_LIVES, silk:START_SILK,
    wave:1, inWave:false, nextWaveAt:0, toSpawn:0, spawnTimer:0,
    enemies:[], nodes:[], particles:[], shots:[], powerups:[], powerupTimer:0,
    nukeFx:[], nukeFlashMs:0,
    boss: null,
    spiderFlash:0 // flash timer for damage
  };
  state.nukeCharge = 0; state.nukeReady = false;

  function reset(full=true){
    state.running=false; state.t=0; state.dt=0; state.last=performance.now();
    state.speedIndex=0; state.score=0; state.lives=START_LIVES; state.silk=START_SILK;
    state.wave=1; state.inWave=false; state.nextWaveAt=0; state.toSpawn=0; state.spawnTimer=0;
    state.enemies.length=0; state.nodes.length=0; state.particles.length=0; state.shots.length=0; state.powerups.length=0; state.powerupTimer=0; state.shake=0;
    state.nukeCharge=0; state.nukeReady=false; state.spiderFlash=0;
    if (full){
      elScore.textContent=state.score; elLives.textContent=state.lives;
      elSilk.textContent=Math.floor(state.silk);
      elWave.textContent=state.wave; elSpeed.textContent=SPEEDS[state.speedIndex]+'x';
      chargeBar.style.width='0%'; nukeBtn.disabled=true; nukeBtn.classList.remove('nukeReady');
    }
    if (nukeBanner) nukeBanner.style.display='none';
    stopMusic();
  }
  reset();

  function createFlyingScore(worldX, worldY, points) {
    const canvasRect = canvas.getBoundingClientRect();
    const screenX = canvasRect.left + (worldX / canvas.width) * canvasRect.width;
    const screenY = canvasRect.top + (worldY / canvas.height) * canvasRect.height;
    const scoreRect = scorePill.getBoundingClientRect();
    const targetX = scoreRect.left + scoreRect.width / 2;
    const targetY = scoreRect.top + scoreRect.height / 2;
    
    const scoreEl = document.createElement('div');
    scoreEl.className = 'flyingScore';
    scoreEl.textContent = '+' + points;
    scoreEl.style.left = screenX + 'px';
    scoreEl.style.top = screenY + 'px';
    scoreEl.style.willChange = 'transform, left, top, opacity, filter';
    document.body.appendChild(scoreEl);
    
    playSound('scorePoint'); // Sound when score launches
    
    const duration = 900, startTime = performance.now();
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime, progress = Math.min(elapsed / duration, 1);
      const eased = progress < 0.5 ? 2*progress*progress : 1-Math.pow(-2*progress+2,2)/2;
      const currentX = screenX + (targetX - screenX) * eased;
      const currentY = screenY + (targetY - screenY) * eased;
      scoreEl.style.left = currentX + 'px';
      scoreEl.style.top = currentY + 'px';
      scoreEl.style.opacity = (1 - progress * 0.25).toString();
      const scale = 1.1 - 0.1*eased;
      const hue = (progress*30)|0; // subtle hue shift
      scoreEl.style.transform = `scale(${scale})`;
      scoreEl.style.filter = `hue-rotate(${hue}deg)`;
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        scoreEl.remove();
        playSound('scoreCollect'); // Sound when score arrives
        scorePill.classList.add('scoreGlow');
        scorePill.style.transform = 'scale(1.15)';
        scorePill.style.transition = 'transform 0.12s';
        // Spawn DOM sparks around score pill center
        (function spawnSparks(){
          const n = 14;
          for(let i=0;i<n;i++){
            const sp = document.createElement('i');
            sp.className = 'scoreSpark';
            const ang = Math.random()*Math.PI*2;
            const dist = 20 + Math.random()*36;
            const dx = Math.cos(ang)*dist;
            const dy = Math.sin(ang)*dist;
            sp.style.left = (targetX-3) + 'px';
            sp.style.top = (targetY-3) + 'px';
            sp.style.setProperty('--dx', dx+'px');
            sp.style.setProperty('--dy', dy+'px');
            document.body.appendChild(sp);
            setTimeout(()=>sp.remove(), 650);
          }
        })();
        setTimeout(() => { scorePill.style.transform = 'scale(1)'; scorePill.classList.remove('scoreGlow'); }, 150);
      }
    };
    requestAnimationFrame(animate);
  }

  function createFlyingHeal(worldX, worldY, amount) {
    const canvasRect = canvas.getBoundingClientRect();
    const screenX = canvasRect.left + (worldX / canvas.width) * canvasRect.width;
    const screenY = canvasRect.top + (worldY / canvas.height) * canvasRect.height;
    const livesRect = livesPill.getBoundingClientRect();
    const targetX = livesRect.left + livesRect.width / 2;
    const targetY = livesRect.top + livesRect.height / 2;

    const el = document.createElement('div');
    el.className = 'flyingHeal';
    el.textContent = '+ ' + amount + ' HP';
    el.style.left = screenX + 'px';
    el.style.top = screenY + 'px';
    el.style.willChange = 'transform, left, top, opacity, filter';
    document.body.appendChild(el);

    const duration = 850, startTime = performance.now();
    const animate = (now) => {
      const p = Math.min((now - startTime) / duration, 1);
      const eased = p < 0.5 ? 2*p*p : 1-Math.pow(-2*p+2,2)/2;
      const cx = screenX + (targetX - screenX) * eased;
      const cy = screenY + (targetY - screenY) * eased;
      el.style.left = cx + 'px';
      el.style.top = cy + 'px';
      el.style.opacity = (1 - p * 0.25).toString();
      el.style.transform = `scale(${1.1 - 0.1*eased})`;
      if (p < 1) requestAnimationFrame(animate); else {
        el.remove();
        // Pill glow and sparks
        livesPill.classList.add('lifeGlow');
        livesPill.style.transform = 'scale(1.12)';
        livesPill.style.transition = 'transform 0.12s';
        (function sparks(){
          const n = 10;
          for(let i=0;i<n;i++){
            const sp = document.createElement('i');
            sp.className = 'healSpark';
            const ang = Math.random()*Math.PI*2;
            const dist = 18 + Math.random()*32;
            const dx = Math.cos(ang)*dist;
            const dy = Math.sin(ang)*dist;
            sp.style.left = (targetX-3) + 'px';
            sp.style.top = (targetY-3) + 'px';
            sp.style.setProperty('--dx', dx+'px');
            sp.style.setProperty('--dy', dy+'px');
            document.body.appendChild(sp);
            setTimeout(()=>sp.remove(), 650);
          }
        })();
        setTimeout(()=>{ livesPill.style.transform='scale(1)'; livesPill.classList.remove('lifeGlow'); }, 150);
      }
    };
    requestAnimationFrame(animate);
  }

  function canvasToWorld(ev){ 
    const r = canvas.getBoundingClientRect(); 
    return {x: (ev.clientX - r.left) * (canvas.width / r.width), y: (ev.clientY - r.top) * (canvas.height / r.height)}; 
  }
  
  canvas.addEventListener('pointerdown', e=>{
    if(!state.running) return; 
    const p=canvasToWorld(e); 
    placeNode(p.x,p.y);
  });
  
  addEventListener('keydown', e=>{
    if (e.key==='r'||e.key==='R'){playSound('button'); showOverlay('SPIDER STRIKE','SYSTEM REBOOT - REINFORCE NEST', true);}
    if (e.key==='+'){playSound('button'); changeSpeed(1);}
    if (e.key==='-'){playSound('button'); changeSpeed(-1);}
    if ((e.key==='n'||e.key==='N') && state.nukeReady){nuke();}
  });
  
  restartBtn.addEventListener('click',()=>{playSound('button'); showOverlay('SPIDER STRIKE','SYSTEM REBOOT - REINFORCE NEST', true);});
  nukeBtn.addEventListener('click', ()=>{if (state.nukeReady) nuke();});
  startBtn.addEventListener('click', ()=>{playSound('button'); overlay.style.display='none'; start();});
  howBtn.addEventListener('click', ()=>{
    playSound('button');
    ovTitle.textContent='[ INFO ]';
    ovMsg.innerHTML = `
      <b>GOAL:</b> PROTECT CENTER NEST<br>
      <b>NODES:</b> CLICK TO DEPLOY STICKY WEB<br>
      NODES WEAR DOWN AS ENEMIES PASS<br>
      <b>STUCK KILL:</b> SLOWED ENEMIES DIE AFTER ${(STUCK_KILL_MS/1000).toFixed(1)}S<br>
      <b>TYPES:</b> BEETLES RESIST WEBS<br>
      ROACHES IMMUNE TO NUKES<br>
      WASPS ARE FAST<br>
      MOTHS DRIFT, LIGHT WEB RESIST<br>
      MANTIS ARE VERY FAST<br>
      <b>NUKE:</b> CHARGE BY SURVIVING WAVES
    `;
  });

  function showOverlay(title,msg,doReset=false){
    ovTitle.textContent=title; ovMsg.innerHTML=msg; overlay.style.display='grid'; state.running=false; if (doReset) reset();
  }
  
  function start(){
    reset(false); 
    state.running=true; 
    state.last=performance.now(); 
    state.nextWaveAt=state.t+800; 
    startMusic(); // Start background music
    requestAnimationFrame(loop);
  }
  
  function changeSpeed(d){state.speedIndex=Math.max(0,Math.min(SPEEDS.length-1,state.speedIndex+d)); elSpeed.textContent=SPEEDS[state.speedIndex]+'x';}

  function scheduleWave(){
    state.inWave=true; 
    state.toSpawn=Math.round(ENEMY_BASE+(state.wave-1)*3.5); 
    state.spawnTimer=0;
    playSound('waveStart'); // Wave start sound
  }

  // (old boss removed)
  
  function spawnEnemy(){
    const side = Math.floor(Math.random()*4); let x,y;
    if (side===0){x=Math.random()*canvas.width; y=-10;}
    else if (side===1){x=canvas.width+10; y=Math.random()*canvas.height;}
    else if (side===2){x=Math.random()*canvas.width; y=canvas.height+10;}
    else {x=-10; y=Math.random()*canvas.height;}
    const t = pickType(state.wave);
    const speed = (t.speed + 0.002*(state.wave-1)) * (0.9 + Math.random()*0.25);
    const hp = Math.round(t.hp + 0.6*(state.wave-1));
    state.enemies.push({x,y, hp, speed, slow:1, stuckTimer:0, type:t, stun:0, vx:0, vy:0});
  }

  function drawPowerupSprite(ctx, p, scale = 0.56) {
    const img = EnemySprites['medic'];
    if (!img || !img.complete) {
      ctx.save();
      ctx.fillStyle = '#1b1b22';
      ctx.strokeStyle = '#ff3344';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      return;
    }
    const sx = EnemyAnim.frame * EnemyAnim.w;
    const sy = 0;
    const dw = EnemyAnim.w * scale;
    const dh = EnemyAnim.h * scale;
    ctx.drawImage(
      img, sx, sy, EnemyAnim.w, EnemyAnim.h,
      Math.round(p.x - dw/2), Math.round(p.y - dh/2),
      Math.round(dw), Math.round(dh)
    );
  }

  function spawnPowerup(){
    // Spawn from a random edge and drift; does NOT home to spider
    const side = Math.floor(Math.random()*4); let x,y;
    if (side===0){x=Math.random()*canvas.width; y=-10;}
    else if (side===1){x=canvas.width+10; y=Math.random()*canvas.height;}
    else if (side===2){x=Math.random()*canvas.width; y=canvas.height+10;}
    else {x=-10; y=Math.random()*canvas.height;}
    const a = Math.random()*Math.PI*2;
    state.powerups.push({x,y, speed:POWERUP_SPEED, vx:Math.cos(a)*POWERUP_SPEED, vy:Math.sin(a)*POWERUP_SPEED});
  }

  function placeNode(x,y){
    if (state.silk < NODE_COST) return;
    const c = CENTER(); const d = Math.hypot(x-c.x, y-c.y);
    if (d < NEST_R + 10) return;
    state.silk = Math.max(0, state.silk - NODE_COST); elSilk.textContent=Math.floor(state.silk);
    // Fire a web shot from center to target; node spawns on impact
    state.shots.push({ x:c.x, y:c.y, tx:x, ty:y, speed:0.40 });
    state.shake = 2;
    playSound('button'); // firing cue; deploy sound on impact
  }

  function addScore(n, worldX, worldY){ 
    state.score += n; 
    elScore.textContent = state.score;
    if (worldX !== undefined && worldY !== undefined) {
      createFlyingScore(worldX, worldY, n);
    }
  }
  
  function damage(n){ 
    state.lives -= n; 
    elLives.textContent=Math.max(0,state.lives); 
    state.shake = 8;
    state.spiderFlash = 300; // Flash spider for 300ms
    playSound('damage'); // Damage sound
    vibrateHit(Math.max(1, Math.min(3, n)));
    if(state.lives<=0) gameOver(); 
  }

  const particles = state.particles;
  function emitBurst(x,y, baseColor, count=12){
    const n = Math.floor(count * 1.3);
    for (let i=0;i<n;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 0.6 + Math.random()*2.2;
      const life = 320 + Math.random()*320;
      const size = 1 + Math.random()*3.2;
      const blur = 6 + Math.random()*12;
      particles.push({x,y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0, max: life,
        size, color: baseColor || COLORS.particle, blur});
    }
  }
  function updateParticles(dt){
    for (let i=particles.length-1;i>=0;i--){
      const p=particles[i]; p.life += dt; p.x += p.vx*dt*0.06; p.y += p.vy*dt*0.06;
      p.vx *= 0.986; p.vy *= 0.986;
      if (p.life >= p.max) particles.splice(i,1);
    }
  }

  function updateNukeFx(dt){
    state.nukeFlashMs = Math.max(0, state.nukeFlashMs - dt);
    for (let i=state.nukeFx.length-1;i>=0;i--){
      const r = state.nukeFx[i];
      r.life += dt;
      r.r += r.grow * dt;
      if (r.life >= r.dur || r.r > r.max) state.nukeFx.splice(i,1);
    }
  }

  function updatePowerups(dt){
    for (let i = state.powerups.length - 1; i >= 0; i--) {
      const p = state.powerups[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      // Bounce at edges
      if (p.x < 2){ p.x = 2; p.vx = Math.abs(p.vx); }
      if (p.x > canvas.width-2){ p.x = canvas.width-2; p.vx = -Math.abs(p.vx); }
      if (p.y < 2){ p.y = 2; p.vy = Math.abs(p.vy); }
      if (p.y > canvas.height-2){ p.y = canvas.height-2; p.vy = -Math.abs(p.vy); }
    }
  }

  function updateShots(dt){
    const shots = state.shots;
    for (let i = shots.length - 1; i >= 0; i--) {
      const s = shots[i];
      const vx = s.tx - s.x, vy = s.ty - s.y; const dist = Math.hypot(vx, vy) || 1;
      const step = s.speed * dt; // pixels per ms
      if (dist <= step + 1) {
        // Impact: spawn node, small burst, sound
        state.nodes.push({ x: s.tx, y: s.ty, r: NODE_R, t: state.t, dur: NODE_DUR0 });
        emitBurst(s.tx, s.ty, COLORS.node, 10);
        vibrateLight();
        // Check for powerup hit (must shoot it)
        const CAPTURE_R = 18;
        for (let j = state.powerups.length - 1; j >= 0; j--) {
          const p = state.powerups[j];
          if (Math.hypot(p.x - s.tx, p.y - s.ty) <= CAPTURE_R) {
            state.powerups.splice(j,1);
            state.lives += POWERUP_HEAL; elLives.textContent = Math.max(0,state.lives);
            emitBurst(s.tx, s.ty, '#ff3366', 22);
            playSound('healthUp');
            createFlyingHeal(s.tx, s.ty, POWERUP_HEAL);
          }
        }
                // Direct enemy hit: kill and heal like powerup
        let healed = 0;
        for (let k = state.enemies.length - 1; k >= 0; k--) {
          const e = state.enemies[k];
          if (Math.hypot(e.x - s.tx, e.y - s.ty) <= CAPTURE_R) {
            state.enemies.splice(k, 1);
            healed += POWERUP_HEAL;
            addScore(6, e.x, e.y);
            emitBurst(e.x, e.y, '#ff3366', 22);
          }
        }
        if (healed > 0) {
          state.lives += healed; elLives.textContent = Math.max(0, state.lives);
          playSound('healthUp');
          createFlyingHeal(s.tx, s.ty, healed);
        }
        playSound('webDeploy');
        shots.splice(i, 1);
        continue;
      }
      const ux = vx / dist, uy = vy / dist;
      s.x += ux * step; s.y += uy * step;
    }
  }
  function drawParticles(){
    for (const p of particles){
      const t = p.life / p.max;
      const a = Math.max(0, 1 - t);
      const s = Math.ceil(p.size);
      ctx.globalAlpha = a;
      ctx.fillStyle = p.color;
      // Glow
      const blur = (p.blur || 8) * (0.6 + 0.4*(1 - t));
      ctx.shadowColor = p.color;
      ctx.shadowBlur = blur;
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), s, s);
      // Simple trail using velocity vector
      const tx1 = p.x - (p.vx*8);
      const ty1 = p.y - (p.vy*8);
      ctx.globalAlpha = a*0.5;
      ctx.fillRect(Math.floor(tx1), Math.floor(ty1), Math.max(1,s-1), Math.max(1,s-1));
      ctx.globalAlpha = 1;
      ctx.shadowBlur = 0;
    }
  }

  function nuke(){
    const center = CENTER();
    let killed = 0;
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      emitBurst(e.x, e.y, (e.type && e.type.color) || COLORS.particle, 40);
      createFlyingScore(e.x, e.y, NUKE_SCORE_PER_KILL);
      state.enemies.splice(i,1); killed++;
    }
    if (killed>0){
      state.score += killed * NUKE_SCORE_PER_KILL;
      elScore.textContent = state.score;
      state.silk = Math.min(SILK_MAX, state.silk + killed * NUKE_SILK_PER_KILL);
      elSilk.textContent = Math.floor(state.silk);
    }
    // Central explosion burst
    emitBurst(center.x, center.y, '#ff8c00', 120);
    emitBurst(center.x, center.y, '#ff3366', 90);
    emitBurst(center.x, center.y, '#39ffd1', 70);
    // Hurt boss if present
    damageBossFromNuke();
    state.nukeCharge = 0; state.nukeReady=false; chargeBar.style.width='0%'; nukeBtn.disabled=true; nukeBtn.classList.remove('nukeReady');
    if (nukeBanner) nukeBanner.style.display='none';
    state.shake = 28;
    playSound('nuke'); // Nuke explosion sound
    // Launch shockwave rings and screen flash
    const maxR = Math.hypot(canvas.width, canvas.height);
    state.nukeFx.push({r:0, grow:0.55*DPR, w:8*DPR, color:'rgba(255,51,102,0.9)', life:0, dur:800, max:maxR});
    state.nukeFx.push({r:0, grow:0.75*DPR, w:5*DPR, color:'rgba(57,255,209,0.8)', life:0, dur:650, max:maxR});
    state.nukeFx.push({r:0, grow:0.38*DPR, w:12*DPR, color:'rgba(255,216,102,0.7)', life:0, dur:950, max:maxR});
    state.nukeFlashMs = 450;
  }

  function loop(now){
    if (!state.running) return;
    requestAnimationFrame(loop);

    const baseDt = now - state.last; state.last = now;
    const dt = baseDt * SPEEDS[state.speedIndex];
    state.dt = dt; state.t += dt;

    if (state.shake > 0) state.shake = Math.max(0, state.shake - dt * 0.03);
    if (state.spiderFlash > 0) state.spiderFlash = Math.max(0, state.spiderFlash - dt);

    updateShots(dt);
    updatePowerups(dt);

    state.silk = Math.min(SILK_MAX, state.silk + SILK_REGEN * (dt/1000)); elSilk.textContent=Math.floor(state.silk);

    if (!state.inWave && state.t >= state.nextWaveAt) scheduleWave();
    if (state.inWave && state.toSpawn > 0){
      state.spawnTimer += dt;
      while (state.spawnTimer > SPAWN_BURST && state.toSpawn > 0){
        state.spawnTimer -= SPAWN_BURST; spawnEnemy(); state.toSpawn--;
      }
    }
    if (state.inWave && state.toSpawn<=0 && state.enemies.length===0){
      state.inWave=false; 
      state.wave++; 
      elWave.textContent=state.wave; 
      state.nextWaveAt = state.t + WAVE_GAP_MS;
      state.silk = Math.min(SILK_MAX, state.silk + 20 + 5*state.wave);
      state.nukeCharge = Math.min(NUKE_CHARGE_MAX, state.nukeCharge + 28);
      playSound('waveComplete'); // Wave complete sound
      if (Math.random() < POWERUP_CHANCE) spawnPowerup();
      // Boss spawns disabled when ENABLE_BOSSES is false
      if (ENABLE_BOSSES) {
        if (state.wave === 5)  spawnBoss(BossKind.BROOD);
        if (state.wave === 9)  spawnBoss(BossKind.HARB);
        if (state.wave === 12) spawnBoss(BossKind.WIDOW);
      }
    }

    // Frequent powerup spawns while running
    state.powerupTimer += dt;
    if (state.powerupTimer >= POWERUP_INTERVAL_MS) {
      if (state.powerups.length < 5) spawnPowerup();
      state.powerupTimer = 0;
    }
    
    const prevCharge = state.nukeCharge;
    state.nukeCharge = Math.min(NUKE_CHARGE_MAX, state.nukeCharge + 0.008 * (dt/16));
    chargeBar.style.width = (state.nukeCharge/NUKE_CHARGE_MAX*100).toFixed(1) + '%';
    
    if (state.nukeCharge >= NUKE_CHARGE_MAX && !state.nukeReady){
      state.nukeReady=true; 
      nukeBtn.disabled=false;
      nukeBtn.classList.add('nukeReady');
      playSound('nukeCharged'); // Nuke charged sound
      if (nukeBanner) nukeBanner.style.display='block';
    }

    const c = CENTER();
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];

      let slow = 1, heavySlow = false;
      for (const n of state.nodes){
        const dx=e.x-n.x, dy=e.y-n.y; const d=Math.hypot(dx,dy);
        if (d < n.r){
          const t = 1 - (d/n.r);
          const s = 1 - (NODE_FADE + (NODE_SLOW - NODE_FADE) * t);
          slow *= s;
          if (t > 0.55) heavySlow = true;
          n.dur -= NODE_DECAY_PER_ENEMY * (dt/1000) * (0.35 + 0.65*t);
        }
      }
      slow = slow + (1 - slow) * (e.type.webResist || 0);
      slow = Math.min(1, Math.max(0.12, slow));

      const need = STUCK_KILL_MS * (e.type.stuckMult || 1);
      if (slow < 0.75 && heavySlow) e.stuckTimer = (e.stuckTimer||0) + dt; else e.stuckTimer = Math.max(0,(e.stuckTimer||0) - dt*1.5);
      if (e.stuckTimer >= need){
        emitBurst(e.x, e.y, '#00ff66', 14);
        addScore(6, e.x, e.y);
        state.silk = Math.min(SILK_MAX, state.silk + 2); elSilk.textContent=Math.floor(state.silk);
        state.shake = 2;
        playSound('enemyKill'); // Enemy kill sound
        state.enemies.splice(i,1); continue;
      }

      if (e.stun>0){
        e.stun -= dt;
        e.vx = (e.vx||0) * 0.92;
        e.vy = (e.vy||0) * 0.92;
      } else {
        const dx = c.x - e.x, dy = c.y - e.y; const dist = Math.hypot(dx,dy)||1;
        const ux = dx / dist, uy = dy / dist;
        const desired = e.speed * slow; // px/ms
        const alpha = 1 - Math.exp(-dt * 0.02); // smoothing factor 0..1
        e.vx = (e.vx||0) + (ux*desired - (e.vx||0)) * alpha;
        e.vy = (e.vy||0) + (uy*desired - (e.vy||0)) * alpha;
        e.x += e.vx * dt; e.y += e.vy * dt;
        const nd = Math.hypot(c.x - e.x, c.y - e.y);
        if (nd <= NEST_R){state.enemies.splice(i,1); damage(1); continue;}
      }
    }

    // Boss update (new system)
    updateBoss(dt);

    for (let i=state.nodes.length-1;i>=0;i--){if (state.nodes[i].dur <= 0) state.nodes.splice(i,1);}

    updateParticles(dt);
    updateNukeFx(dt);
    render();
  }

  function render(){
    ctx.save();
    
    if (state.shake > 0) {
      const sx = (Math.random() - 0.5) * state.shake;
      const sy = (Math.random() - 0.5) * state.shake;
      ctx.translate(sx, sy);
    }

    // Advance enemy animation
    stepEnemyAnim(performance.now());

    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Pixelated spiderweb background
    {
      const c = CENTER();
      ctx.globalAlpha = 0.35;
      // Concentric rings
      const maxR = Math.max(
        Math.hypot(c.x, c.y),
        Math.hypot(canvas.width - c.x, c.y),
        Math.hypot(c.x, canvas.height - c.y),
        Math.hypot(canvas.width - c.x, canvas.height - c.y)
      );
      ctx.lineWidth = 1;
      for (let r = 16; r < maxR; r += 16) {
        drawPixelCircle(Math.floor(c.x), Math.floor(c.y), Math.floor(r), COLORS.grid, true);
      }

      // Radial lines
      const radials = 16;
      for (let i = 0; i < radials; i++) {
        const a = (i / radials) * Math.PI * 2;
        const x1 = Math.floor(c.x + Math.cos(a) * (maxR + 8));
        const y1 = Math.floor(c.y + Math.sin(a) * (maxR + 8));
        drawPixelLine(Math.floor(c.x), Math.floor(c.y), x1, y1, COLORS.grid);
      }
      ctx.globalAlpha = 1;
    }

    const c = CENTER();

    // Draw web shots (strand + head)
    for (const s of state.shots) {
      const strandColor = '#ffe9cc';
      // anchor from current center to shot head for an elastic strand feel
      drawPixelLine(Math.floor(c.x), Math.floor(c.y), Math.floor(s.x), Math.floor(s.y), strandColor);
      // slight thickness by offset
      drawPixelLine(Math.floor(c.x+1), Math.floor(c.y), Math.floor(s.x+1), Math.floor(s.y), strandColor);
      // head
      ctx.fillStyle = strandColor;
      ctx.fillRect(Math.floor(s.x)-1, Math.floor(s.y)-1, 2, 2);
    }

    for (const n of state.nodes) {
      const steps = 8;
      for (let i = steps; i > 0; i--) {
        const a = (i / steps) * 0.25;
        ctx.globalAlpha = a;
        ctx.fillStyle = COLORS.web;
        const r = (n.r / steps) * i;
        drawPixelCircle(n.x, n.y, r, COLORS.web);
      }
      ctx.globalAlpha = 1;

      // Pixelated cobweb texture overlay (radials + rings)
      {
        const webColor = '#ffe9cc';
        ctx.globalAlpha = 0.35;
        const radials = 12;
        for (let i = 0; i < radials; i++){
          const a = (i / radials) * Math.PI * 2;
          const ex = Math.floor(n.x + Math.cos(a) * n.r);
          const ey = Math.floor(n.y + Math.sin(a) * n.r);
          drawPixelLine(Math.floor(n.x), Math.floor(n.y), ex, ey, webColor);
        }
        for (let rr = 6; rr < n.r; rr += 6){
          drawPixelRing(Math.floor(n.x), Math.floor(n.y), Math.floor(rr), webColor, 24);
        }
        ctx.globalAlpha = 1;
      }

      const coreSize = 4;
      ctx.fillStyle = COLORS.nodeDim;
      ctx.fillRect(Math.floor(n.x - coreSize/2), Math.floor(n.y - coreSize/2), coreSize, coreSize);
      
      const p = Math.max(0, Math.min(1, n.dur / NODE_DUR0));
      ctx.fillStyle = p > 0.5 ? '#ff8c00' : (p > 0.25 ? '#ffb84d' : '#cc5500');
      const durSize = Math.ceil(p * 3);
      if (durSize > 0) {
        ctx.fillRect(Math.floor(n.x - 1), Math.floor(n.y - 6), durSize, 1);
      }
    }

    drawParticles();

    // Draw nuke shockwave FX
    if (state.nukeFx.length){
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      for (const r of state.nukeFx){
        const p = Math.min(1, r.life / r.dur);
        const alpha = (1 - p) * parseFloat(r.color.split(',')[3]||1);
        ctx.strokeStyle = r.color;
        ctx.globalAlpha = Math.max(0.1, 1 - p);
        ctx.lineWidth = r.w * (1 - p*0.6);
        ctx.beginPath();
        ctx.arc(canvas.width/2, canvas.height/2, r.r, 0, Math.PI*2);
        ctx.stroke();
      }
      ctx.restore();
    }

    // Draw powerups
    for (const p of state.powerups) {
      drawPowerupSprite(ctx, p, 0.56);
    }

    // Draw enemies with animated sprites
    for (const e of state.enemies) {
      // Draw sprite
      const scale = SCALE_BY_TYPE[e.type.key] || 0.30;
      drawEnemySprite(ctx, e, scale);
      
      // Stuck indicator (drawn after sprite)
      if (e.stuckTimer && e.stuckTimer > 0) {
        const need = STUCK_KILL_MS * (e.type.stuckMult || 1);
        const p = Math.min(1, e.stuckTimer / need);
        ctx.fillStyle = '#ff8c00';
        const ring = Math.floor(6 + p * 3);
        drawPixelCircle(e.x, e.y, ring, '#ff8c00', true);
      }
      
      // Stun indicator (drawn after sprite)
      if (e.stun > 0) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        drawPixelCircle(e.x, e.y, 8, '#ffffff', true);
      }
    }

    // Draw boss (new system):
    drawBoss(ctx);

    // Nest - chunky pixel art - ALWAYS IN CENTER
    // Remove outer circle glow - only keep nest body and outline
    
    // Nest body
    ctx.fillStyle = COLORS.nestCore;
    drawPixelCircle(c.x, c.y, NEST_R, COLORS.nestCore, false);
    
    // Nest outline
    ctx.strokeStyle = COLORS.nest;
    ctx.lineWidth = 2;
    drawPixelCircle(c.x, c.y, NEST_R, COLORS.nest, true);
    
    // Animated spider sprite in center - DOUBLED SIZE
    ctx.save();
    drawSpiderSprite(ctx, c.x, c.y, 0.6); // Scale 0.6 for double size
    
    // Flash effect when damaged
    if (state.spiderFlash > 0) {
      flashSpider(ctx, c.x, c.y, 0.6); // Match doubled size
    }
    ctx.restore();

    // Screen flash overlay for nuke
    if (state.nukeFlashMs > 0){
      const a = Math.min(0.45, state.nukeFlashMs / 450 * 0.45);
      ctx.save(); ctx.globalAlpha = a; ctx.fillStyle = '#ff8c00';
      ctx.fillRect(0,0,canvas.width,canvas.height); ctx.restore();
    }

    ctx.restore();
  }

  function drawPixelCircle(cx, cy, r, color, outlineOnly = false) {
    if (outlineOnly) {
      ctx.strokeStyle = color;
      const points = [];
      for (let a = 0; a < Math.PI * 2; a += Math.PI / 16) {
        points.push({x: Math.floor(cx + Math.cos(a) * r), y: Math.floor(cy + Math.sin(a) * r)});
      }
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      }
    } else {
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawPixelLine(x0, y0, x1, y1, color) {
    let x = Math.floor(x0), y = Math.floor(y0);
    const tx = Math.floor(x1), ty = Math.floor(y1);
    const dx = Math.abs(tx - x), dy = Math.abs(ty - y);
    const sx = x < tx ? 1 : -1;
    const sy = y < ty ? 1 : -1;
    let err = dx - dy;
    ctx.fillStyle = color;
    while (true) {
      ctx.fillRect(x, y, 1, 1);
      if (x === tx && y === ty) break;
      const e2 = err * 2;
      if (e2 > -dy) { err -= dy; x += sx; }
      if (e2 < dx) { err += dx; y += sy; }
    }
  }

  function drawPixelRing(cx, cy, r, color, segments = 24){
    const pts = [];
    for (let i = 0; i < segments; i++){
      const a = (i / segments) * Math.PI * 2;
      pts.push({ x: Math.floor(cx + Math.cos(a) * r), y: Math.floor(cy + Math.sin(a) * r) });
    }
    for (let i = 0; i < pts.length; i++){
      const p1 = pts[i], p2 = pts[(i+1)%pts.length];
      drawPixelLine(p1.x, p1.y, p2.x, p2.y, color);
    }
  }

  function gameOver(){
    state.running=false; 
    overlay.style.display='grid';
    ovTitle.textContent='[ GAME OVER ]';
    const prevBest = loadBest();
    const isBest = state.score > prevBest;
    const best = isBest ? state.score : prevBest;
    if (isBest) saveBest(best);
    ovMsg.innerHTML = `FINAL SCORE: <b>${state.score}</b><br>
      BEST SCORE: <b>${best}</b>${isBest? ' <span style="color:var(--ok)">NEW BEST!</span>' : ''}<br>
      WAVE: <b>${state.wave}</b><br><br>NEST DESTROYED!`;
    startBtn.textContent='RETRY';
    playSound('gameOver'); // Game over sound
    stopMusic(); // Stop background music
  }

  window.__SPIDER_NUKE = nuke;
  overlay.style.display='grid';
})();
</script>
</body>
</html>
