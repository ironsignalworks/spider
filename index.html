<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" />
<title>SPIDER STRIKE</title>
<style>
  @import url('https://fonts.googleapis.com/css2?family=VT323&display=swap');
  @font-face{
    font-family:'Still Time';
    src:url('still_time/Still Time.otf') format('opentype');
    font-display:swap;
  }
  
  :root{
    --bg:#0c0602; --ink:#d6f0ff; --muted:#ffd9aa;
    --neon:#ff8c00; --ok:#ff8c00; --warn:#ffb84d; --bad:#cc5500;
    --grid:#2a1100;
  }
  *{box-sizing:border-box}
  
  html,body{
    height:100%;width:100%;margin:0;padding:0;background:#000;
    color:var(--ink);font-family:'VT323',monospace;font-size:20px;
    image-rendering:pixelated;image-rendering:crisp-edges;overflow:hidden;
  }
  
  .wrap{
    position:fixed;inset:0;display:grid;grid-template-rows:auto 1fr auto;
    background:linear-gradient(180deg, #0b0500 0%, #1a0e00 100%);
    border:4px solid var(--neon);box-shadow:inset 0 0 80px #ff8c0040;
  }
  
  .wrap::before {
    content:"";position:absolute;inset:0;
    background:repeating-linear-gradient(0deg,rgba(0,0,0,0.15),rgba(0,0,0,0.15) 1px,transparent 1px,transparent 2px);
    pointer-events:none;z-index:1000;animation:scanline 8s linear infinite;
  }
  
  @keyframes scanline {
    0%{transform:translateY(0)} 100%{transform:translateY(4px)}
  }
  
  @keyframes flicker {
    0%,100%{opacity:1} 50%{opacity:0.96}
  }
  
  header,footer{
    display:flex;align-items:center;gap:.6rem;padding:.5rem 1rem;
    background:#000;border:3px solid var(--neon);text-shadow:0 0 8px currentColor;
  }
  
  header{justify-content:space-between;user-select:none;animation:flicker 0.15s infinite;}
  
  .brand{
    letter-spacing:.08em;font-size:1.6em;color:var(--neon);
    text-shadow:0 0 10px var(--neon),0 0 20px var(--neon),2px 2px 0 #000;
    font-family:'Still Time','VT323',monospace;
  }
  
  .hud{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;}
  
  .pill{
    padding:.3rem .6rem;border:2px solid var(--ok);background:#000;font-size:1em;
    color:var(--ok);text-shadow:0 0 6px var(--ok);box-shadow:inset 0 0 8px #ff8c0040;
    position:relative;transition:transform 0.1s;
  }
  
  .btn{
    appearance:none;border:3px solid var(--neon);background:#000;color:var(--neon);
    padding:.3rem .7rem;cursor:pointer;font-family:'VT323',monospace;font-size:1em;
    text-shadow:0 0 6px var(--neon);transition:all 0.1s;
  }
  
  .btn:hover{background:var(--neon);color:#000;box-shadow:0 0 20px var(--neon);}
  .btn:active{transform:scale(0.95);}
  
  #gameContainer{position:relative;width:100%;height:100%;overflow:hidden;}
  
  canvas{
    display:block;width:100%;height:100%;image-rendering:pixelated;
        image-rendering:crisp-edges;cursor:crosshair;filter:contrast(1.1);
  }

  /* Mobile layout tweaks */
  @media (max-width: 600px){
    html,body{font-size:16px}
    .wrap{border-width:3px}
    header,footer{padding:.4rem .6rem;border-width:2px}
    .brand{font-size:1.3em;letter-spacing:.06em;text-align:center}
    header{flex-direction:column;align-items:stretch;gap:.4rem}
    .hud{justify-content:center;flex-wrap:wrap;gap:.3rem}
    .pill{font-size:.9em;padding:.2rem .4rem}
    .btn{font-size:.9em;padding:.22rem .48rem}
    .charge{width:60px;height:6px}
    .soundToggle{font-size:.75em;padding:.18rem .4rem}
    footer{font-size:.85em;text-align:center}
  }
  }
  
  footer{justify-content:center;color:var(--ink);font-size:1em;user-select:none;}
  .footerCenter{flex:1;text-align:center}
  .ironSig{color:var(--muted);text-decoration:none;font-size:.95em}
  .ironSig:hover{color:var(--ok);text-shadow:0 0 8px var(--ok)}
  
  .overlay{
    position:absolute;inset:0;display:none;place-items:center;
    background:radial-gradient(circle,#00000090,#000000e0);z-index:999;
  }
  
  .card{
    background:#000;border:4px solid var(--neon);
    box-shadow:0 0 40px var(--neon), inset 0 0 20px #ff8c0040;
    padding:20px 25px;max-width:min(92vw,620px);text-align:center;
  }
  
  .card h2{
    margin:.2rem 0 0;font-size:2em;letter-spacing:.12em;color:var(--neon);
    text-shadow:0 0 10px var(--neon),0 0 20px var(--neon);
    font-family:'Still Time','VT323',monospace;
  }
  
  .card p{margin:.8rem 0 1.2rem;color:var(--ok);line-height:1.4;}
  
  .kbd{
    border:2px solid var(--ok);background:#000;padding:.3rem .5rem;
    color:var(--ok);text-shadow:0 0 6px var(--ok);
  }
  
  .nukeBtn{
    padding:.3rem .7rem;border-color:var(--warn);color:var(--warn);
    text-shadow:0 0 6px var(--warn);
  }
  
  .nukeBtn:hover{background:var(--warn);color:#000;box-shadow:0 0 20px var(--warn);}
  
  .charge{
    width:72px;height:8px;background:#001100;border:2px solid var(--ok);overflow:hidden;
  }
  
  .charge>i{
    display:block;height:100%;background:var(--warn);box-shadow:0 0 8px var(--warn);width:0%;
  }
  
  .small{font-size:.9em;color:var(--muted);}
  
  .flyingScore{
    position:absolute;font-family:'VT323',monospace;font-size:28px;
    color:#ff66cc;text-shadow:0 0 10px #ff66cc,0 0 20px #ff66cc;
    pointer-events:none;z-index:100;font-weight:bold;
  }
  
  .soundToggle{
    z-index:1;
    padding:.22rem .48rem;border:2px solid var(--ok);background:#000;
    color:var(--ok);font-family:'VT323',monospace;font-size:.85em;
    cursor:pointer;text-shadow:0 0 6px var(--ok);
    margin-left:auto;
  }
  
  .soundToggle:hover{background:var(--ok);color:#000;}
  
  body::after{
    content:"";position:fixed;inset:0;
    background:radial-gradient(ellipse at center,transparent 0%,rgba(0,0,0,0.3) 100%);
    pointer-events:none;z-index:999;
  }

  /* Nuke Ready Banner */
  .nukeBanner{
    position:fixed;left:50%;top:40%;transform:translate(-50%,-50%);
    padding:.4rem .8rem;border:4px solid #ff3366;background:#000;
    color:#ff3366;text-shadow:0 0 10px #ff3366,0 0 20px #ff3366;
    box-shadow:0 0 30px #ff3366, inset 0 0 14px #ff336640;
    font-family:'Still Time','VT323',monospace;letter-spacing:.1em;
    z-index:1100;pointer-events:none;display:none;
    animation:bannerFlash 0.7s steps(2, start) infinite;
    text-align:center;
  }
  .nukeBanner .nbTitle{font-size:2.0em;line-height:1;margin-bottom:.12em;white-space:nowrap}
  .nukeBanner .nbHint{font-size:1.0em;line-height:1;color:#ff99aa;font-family:'VT323',monospace}
  @keyframes bannerFlash{0%{opacity:1;filter:brightness(1.2)}50%{opacity:.3;filter:brightness(.9)}100%{opacity:1;filter:brightness(1.2)}}
</style>
</head>
<body>
<div class="wrap">
    <header>
    <div class="brand">SPIDER STRIKE</div>
    <div class="hud">
      <div class="pill" id="scorePill">SCR:<span id="score">0</span></div>
      <div class="pill">HP:<span id="lives">10</span></div>
      <div class="pill">SLK:<span id="silk">50</span></div>
      <div class="pill">CST:<span id="cost">25</span></div>
      <div class="pill">WV:<span id="wave">1</span></div>
      <div class="pill">SPD:<span id="speed">1x</span></div>
      <div class="pill small" style="display:flex;flex-direction:column;align-items:center;padding:.2rem .5rem">
        <div style="font-size:.8rem">NUKE</div>
        <div class="charge"><i id="chargeBar"></i></div>
      </div>
      <button id="restart" class="btn">[R]</button>
      <button id="nukeBtn" class="btn nukeBtn" disabled>[N]</button>
    </div>
  </header>

  <div id="gameContainer"><canvas id="game"></canvas></div>
  <div id="nukeBanner" class="nukeBanner" aria-live="polite">
    <div class="nbTitle">NUKE 'EM HIGH!</div>
    <div class="nbHint">[PRESS N]</div>
  </div>

  <footer>
    <a class="ironSig" href="https://ironsignalworks.com" target="_blank" rel="noopener">IRON SIGNAL WORKS</a>
    <span class="footerCenter">| CLICK TO DEPLOY WEB NODES | [R]ESTART | [N]UKE | [+]/[-]SPEED |</span>
    <button id="soundToggle" class="soundToggle">SFX ON</button>
  </footer>
  

  <div id="overlay" class="overlay">
    <div class="card">
      <h2 id="ovTitle">SPIDER STRIKE</h2>
      <p id="ovMsg" class="small">
        THE NEST IS UNDER ATTACK!<br>
        DEPLOY WEB NODES TO SLOW ENEMIES<br>
        NODES WEAR DOWN WITH TRAFFIC<br>
        ENEMIES DIE IF STUCK TOO LONG<br>
        SOME RESIST WEBS - SOME RESIST NUKES<br>
        <br>
        <b>CONTROLS</b><br>
        CLICK: DEPLOY WEB NODE<br>
        R: RESTART RUN<br>
        N: NUKE (WHEN CHARGED)<br>
        + / -: CHANGE GAME SPEED
      </p>
      <div id="ovKeys" style="display:flex;gap:.5rem;justify-content:center;margin-bottom:.8rem">
        <span class="kbd">CLICK</span><span class="kbd">R</span><span class="kbd">N</span><span class="kbd">+</span><span class="kbd">-</span>
      </div>
      <div style="display:flex;gap:.6rem;justify-content:center">
        <button id="startBtn" class="btn">START</button>
        <button id="howBtn" class="btn">INFO</button>
      </div>
    </div>
  </div>
</div>



<script>
(() => {
  "use strict";
  
  /*** SPIDER SPRITE ***/
  const SPIDER_SVG_DATAURI =
    'data:image/svg+xml;utf8,' +
    encodeURIComponent(`<?xml version="1.0" encoding="UTF-8"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#ffd000;stroke-width:1.8;stroke-linecap:round;stroke-linejoin:round}
      .s{fill:#0c0c12;stroke:#ffd000;stroke-width:1.2}
      .g{fill:rgba(255,208,0,0.12)}
      .w{stroke:rgba(255,255,255,0.35);stroke-width:1;stroke-linecap:round}
    </style>
  </defs>

  <!-- FRAME 0 (x:0..31) -->
  <g transform="translate(0,0)">
    <!-- soft glow -->
    <circle cx="16" cy="16" r="7" class="g"/>
    <!-- abdomen + cephalothorax -->
    <ellipse cx="16" cy="16" rx="7" ry="5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3.5" ry="3" class="o"/>

    <!-- legs left -->
    <path d="M13 14 C5 10, 5 22, 10 22" class="o"/>
    <path d="M13 18 C6 16, 6 24, 11 24" class="o"/>
    <path d="M14 12 C7 8, 7 14, 10 16" class="o"/>
    <!-- legs right -->
    <path d="M19 14 C27 10, 27 22, 22 22" class="o"/>
    <path d="M19 18 C26 16, 26 24, 21 24" class="o"/>
    <path d="M18 12 C25 8, 25 14, 22 16" class="o"/>

    <!-- little fangs highlight -->
    <path d="M10 16 l-2 1" class="w"/>
    <path d="M10 16 l-2 -1" class="w"/>
  </g>

  <!-- FRAME 1 (x:32..63) -->
  <g transform="translate(32,0)">
    <!-- soft glow -->
    <circle cx="16" cy="16" r="7" class="g"/>
    <!-- abdomen + cephalothorax -->
    <ellipse cx="16" cy="16" rx="7" ry="5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3.5" ry="3" class="o"/>

    <!-- legs shifted (crawl) -->
    <!-- legs left -->
    <path d="M13 14 C6 9, 6 15, 9 17" class="o"/>
    <path d="M13 18 C5 20, 6 26, 12 25" class="o"/>
    <path d="M14 12 C8 10, 6 12, 9 14" class="o"/>
    <!-- legs right -->
    <path d="M19 14 C26 9, 26 15, 23 17" class="o"/>
    <path d="M19 18 C27 20, 26 26, 20 25" class="o"/>
    <path d="M18 12 C24 10, 26 12, 23 14" class="o"/>

    <!-- little fangs highlight -->
    <path d="M10 16 l-2 1" class="w"/>
    <path d="M10 16 l-2 -1" class="w"/>
  </g>
</svg>`);

  const spiderImg = new Image();
  spiderImg.decoding = 'async';
  spiderImg.src = SPIDER_SVG_DATAURI;

  // Spider animation state
  const spiderAnim = { t: 0, frame: 0, w: 32, h: 32, speedMs: 140 };

  function drawSpiderSprite(ctx, x, y, scale = 1) {
    // advance animation (toggle frames every speedMs)
    const now = performance.now();
    if (!spiderAnim.t) spiderAnim.t = now;
    if (now - spiderAnim.t > spiderAnim.speedMs) {
      spiderAnim.t = now;
      spiderAnim.frame = (spiderAnim.frame + 1) % 2; // 0 or 1
    }
    const sx = spiderAnim.frame * spiderAnim.w; // source x on sheet
    const sy = 0;

    const dw = spiderAnim.w * scale;
    const dh = spiderAnim.h * scale;
    // draw centered at (x,y)
    ctx.drawImage(
      spiderImg,
      sx, sy, spiderAnim.w, spiderAnim.h,
      Math.round(x - dw/2), Math.round(y - dh/2),
      Math.round(dw), Math.round(dh)
    );
  }

  function flashSpider(ctx, x, y, scale = 0.6) {
    ctx.save();
    ctx.globalCompositeOperation = 'screen';
    ctx.globalAlpha = 0.5;
    drawSpiderSprite(ctx, x, y, scale);
    ctx.restore();
  }
  
  /*** ENEMY SPRITES ***/
  function makeDataURI(svg) {
    return 'data:image/svg+xml;utf8,' + encodeURIComponent(svg);
  }

  const SPRITE_SHEETS = {
    gnat: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#00e5ff;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .w{fill:rgba(0,229,255,0.16)}
      .g{fill:rgba(0,229,255,0.08)}
    </style>
  </defs>
  <!-- GNAT: tiny flyer with wings -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings -->
    <ellipse cx="14" cy="12" rx="6" ry="3.5" class="w"/>
    <ellipse cx="20" cy="12" rx="6" ry="3.5" class="w"/>
    <!-- body -->
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3" ry="2.5" class="o"/>
    <!-- legs -->
    <path d="M18 18 l 5 4" class="o"/>
    <path d="M14 18 l -5 4" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings flutter -->
    <ellipse cx="13" cy="13" rx="7" ry="3" class="w"/>
    <ellipse cx="21" cy="11.5" rx="5.5" ry="2.8" class="w"/>
    <!-- body -->
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3" ry="2.5" class="o"/>
    <!-- legs alt -->
    <path d="M18 18 l 6 2" class="o"/>
    <path d="M14 18 l -6 2" class="o"/>
  </g>
</svg>`),

    beetle: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#ffd000;stroke-width:1.8;stroke-linecap:round;stroke-linejoin:round}
      .s{fill:#0c0c12;stroke:#ffd000;stroke-width:1.2}
      .g{fill:rgba(255,208,0,0.12)}
    </style>
  </defs>
  <!-- BEETLE: chunky shell, slow, web-resistant -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="9" class="g"/>
    <!-- elytra split -->
    <path d="M10,12 q6,-4 12,0 v8 q-6,4 -12,0 z" class="o"/>
    <line x1="16" y1="12" x2="16" y2="20" class="s"/>
    <!-- head -->
    <ellipse cx="11" cy="16" rx="3" ry="2.6" class="o"/>
    <!-- legs -->
    <path d="M12 13 l -6 2" class="o"/>
    <path d="M12 16 l -6 0" class="o"/>
    <path d="M12 19 l -6 -2" class="o"/>
    <path d="M20 13 l 6 2" class="o"/>
    <path d="M20 16 l 6 0" class="o"/>
    <path d="M20 19 l 6 -2" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="9" class="g"/>
    <!-- elytra sway -->
    <path d="M10,12 q6,-4 12,0 v8 q-6,4 -12,0 z" class="o"/>
    <line x1="16" y1="12" x2="16" y2="20" class="s"/>
    <!-- head -->
    <ellipse cx="11" cy="16" rx="3.2" ry="2.4" class="o"/>
    <!-- legs alt stance -->
    <path d="M12 13 l -5 3" class="o"/>
    <path d="M12 16 l -6 1" class="o"/>
    <path d="M12 19 l -5 -3" class="o"/>
    <path d="M20 13 l 5 3" class="o"/>
    <path d="M20 16 l 6 1" class="o"/>
    <path d="M20 19 l 5 -3" class="o"/>
  </g>
</svg>`),

    roach: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#00e5ff;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .w{fill:rgba(0,229,255,0.16)}
      .g{fill:rgba(0,229,255,0.08)}
    </style>
  </defs>
  <!-- ROACH: long body, antennae, nuke-immune -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <ellipse cx="16" cy="16" rx="9" ry="5" class="g"/>
    <ellipse cx="16" cy="16" rx="8" ry="4.5" class="o"/>
    <ellipse cx="11.8" cy="16" rx="3" ry="2.4" class="o"/>
    <!-- antennae -->
    <path d="M10 15 q -5 -4, -8 -6" class="a"/>
    <path d="M10 17 q -5  4, -8  6" class="a"/>
    <!-- legs -->
    <path d="M12 13 l -6 1" class="o"/>
    <path d="M20 13 l 6 1" class="o"/>
    <path d="M12 19 l -6 -1" class="o"/>
    <path d="M20 19 l 6 -1" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <ellipse cx="16" cy="16" rx="9" ry="5" class="g"/>
    <ellipse cx="16" cy="16" rx="8" ry="4.5" class="o"/>
    <ellipse cx="11.6" cy="16" rx="3" ry="2.4" class="o"/>
    <!-- antennae sway -->
    <path d="M10 15 q -6 -3, -9 -4" class="a"/>
    <path d="M10 17 q -6  3, -9  4" class="a"/>
    <!-- legs alt -->
    <path d="M12 13 l -5 2" class="o"/>
    <path d="M20 13 l 5 2" class="o"/>
    <path d="M12 19 l -5 -2" class="o"/>
    <path d="M20 19 l 5 -2" class="o"/>
  </g>
</svg>`),

    wasp: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#00e5ff;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .w{fill:rgba(0,229,255,0.16)}
      .g{fill:rgba(0,229,255,0.08)}
    </style>
  </defs>
  <!-- WASP: fast, striped abdomen, stinger -->
  <!-- Frame 0 -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings -->
    <ellipse cx="14" cy="12" rx="6.5" ry="3" class="w"/>
    <ellipse cx="20" cy="12" rx="6.5" ry="3" class="w"/>
    <!-- thorax/abdomen -->
    <ellipse cx="16" cy="16" rx="6.5" ry="4.2" class="o"/>
    <path d="M13 16 h6" class="y"/>
    <path d="M13 18 h6" class="y"/>
    <!-- head -->
    <ellipse cx="11.8" cy="16" rx="2.8" ry="2.4" class="o"/>
    <!-- stinger -->
    <path d="M22 16 l 4 0" class="o"/>
  </g>
  <!-- Frame 1 -->
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <!-- wings tilt -->
    <ellipse cx="13" cy="11.5" rx="6.8" ry="2.6" class="w"/>
    <ellipse cx="21" cy="12.5" rx="6.0" ry="2.4" class="w"/>
    <!-- thorax/abdomen -->
    <ellipse cx="16" cy="16" rx="6.5" ry="4.2" class="o"/>
    <path d="M13 16 h6" class="y"/>
    <path d="M13 18 h6" class="y"/>
    <!-- head -->
    <ellipse cx="12.0" cy="16" rx="2.6" ry="2.2" class="o"/>
    <!-- stinger -->
    <path d="M22 16 l 4.5 0" class="o"/>
  </g>
</svg>`),

    medic: makeDataURI(`<?xml version="1.0"?>
<svg width="64" height="32" viewBox="0 0 64 32" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0c0c12;stroke:#ff3344;stroke-width:1.6;stroke-linecap:round;stroke-linejoin:round}
      .g{fill:rgba(255,48,64,0.18)}
    </style>
  </defs>
  <!-- MEDIC BUG: small red bug, 2 frames -->
  <g transform="translate(0,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.5" cy="16" rx="3" ry="2.5" class="o"/>
    <path d="M18 18 l 5 3" class="o"/>
    <path d="M14 18 l -5 3" class="o"/>
  </g>
  <g transform="translate(32,0)">
    <circle cx="16" cy="16" r="8" class="g"/>
    <ellipse cx="16" cy="16" rx="6" ry="4.5" class="o"/>
    <ellipse cx="12.8" cy="16" rx="3" ry="2.5" class="o"/>
    <path d="M18 18 l 6 2" class="o"/>
    <path d="M14 18 l -6 2" class="o"/>
  </g>
</svg>`)
  };

  // Preload enemy sprite images
  const EnemySprites = {};
  for (const [key, uri] of Object.entries(SPRITE_SHEETS)) {
    const img = new Image();
    img.decoding = 'async';
    img.src = uri;
    EnemySprites[key] = img;
  }

  // Enemy animation state (shared across all enemies)
  const EnemyAnim = {
    w: 32, h: 32,
    speedMs: 120,
    last: 0, frame: 0
  };

  function stepEnemyAnim(now) {
    if (!EnemyAnim.last) EnemyAnim.last = now;
    if (now - EnemyAnim.last > EnemyAnim.speedMs) {
      EnemyAnim.last = now;
      EnemyAnim.frame = (EnemyAnim.frame + 1) % 2;
    }
  }

  // Scale by enemy type to match visual size - DOUBLED
  const SCALE_BY_TYPE = {
    gnat: 0.56,
    beetle: 0.64,
    roach: 0.60,
    wasp: 0.60
  };

  function drawEnemySprite(ctx, enemy, scale = 1) {
    const img = EnemySprites[enemy.type?.key || 'gnat'];
    if (!img || !img.complete) {
      // Fallback placeholder if not loaded
      ctx.save();
      ctx.fillStyle = '#1b1b22';
      ctx.strokeStyle = (enemy.type && enemy.type.color) || '#fff';
      ctx.lineWidth = 1.5;
      ctx.beginPath(); 
      ctx.arc(enemy.x, enemy.y, 4, 0, Math.PI*2); 
      ctx.fill(); 
      ctx.stroke();
      ctx.restore();
      return;
    }
    const sx = EnemyAnim.frame * EnemyAnim.w;
    const sy = 0;
    const dw = EnemyAnim.w * scale;
    const dh = EnemyAnim.h * scale;
    ctx.drawImage(
      img, sx, sy, EnemyAnim.w, EnemyAnim.h,
      Math.round(enemy.x - dw/2), Math.round(enemy.y - dh/2),
      Math.round(dw), Math.round(dh)
    );
  }

  // Boss sprite sheet (embedded SVG, two frames side-by-side 128x96)
  function makeDataURI(svg){ return 'data:image/svg+xml;utf8,'+encodeURIComponent(svg); }
  const BOSS_BLACK_WIDOW_URI = makeDataURI(`<?xml version="1.0"?>
<svg width="256" height="96" viewBox="0 0 256 96" xmlns="http://www.w3.org/2000/svg">
  <defs>
    <style>
      .o{fill:#0b0c0f;stroke:#e6001a;stroke-width:2;stroke-linecap:round;stroke-linejoin:round}
      .g{fill:rgba(230,0,26,0.14)}
      .s{stroke:#e6001a;stroke-width:1.4;stroke-linecap:round}
      .w{fill:#0b0c0f;stroke:#e6001a;stroke-width:1.4}
      .h{fill:#e6001a}
      .hl{stroke:rgba(255,255,255,0.28);stroke-width:1.2;stroke-linecap:round}
    </style>
  </defs>
  <g transform="translate(0,0)">
    <ellipse cx="64" cy="48" rx="60" ry="42" class="g"/>
    <ellipse cx="78" cy="52" rx="38" ry="27" class="o"/>
    <path d="M78,43 c 6,3 6,9 0,12 c -6,-3 -6,-9 0,-12 z" class="h"/>
    <path d="M50 44 l 16 0" class="t"/>
    <path d="M48 54 l 20 0" class="t"/>
    <path d="M52 64 l 18 0" class="t"/>
    <ellipse cx="48" cy="48" rx="20" ry="14" class="o"/>
    <path d="M46 24 l -4 -10" class="o"/>
    <path d="M50 22 l -3 -12" class="o"/>
    <path d="M54 22 l  0 -11" class="o"/>
    <path d="M58 24 l  3 -10" class="o"/>
    <circle cx="56" cy="58" r="3" class="p"/>
    <circle cx="64" cy="60" r="3" class="p"/>
    <path d="M38 40 C 10 24, 8 50, 22 56" class="o"/>
    <path d="M36 48 C  6 44, 8 70, 26 72" class="o"/>
    <path d="M38 56 C  8 64, 10 88, 30 86" class="o"/>
    <path d="M58 40 C 86 24, 88 50, 74 56" class="o"/>
    <path d="M60 48 C 90 44, 88 70, 70 72" class="o"/>
    <path d="M58 56 C 88 64, 86 88, 66 86" class="o"/>
    <path d="M40 50 l -8 4" class="w"/>
    <path d="M40 46 l -8 -4" class="w"/>
  </g>
  <g transform="translate(128,0)">
    <ellipse cx="64" cy="48" rx="60" ry="42" class="g"/>
    <ellipse cx="79" cy="50.5" rx="38" ry="27" class="o"/>
    <path d="M79,41.5 c 6,3 6,9 0,12 c -6,-3 -6,-9 0,-12 z" class="h"/>
    <path d="M52 45 l 16 0" class="t"/>
    <path d="M50 55 l 20 0" class="t"/>
    <path d="M54 65 l 18 0" class="t"/>
    <ellipse cx="49" cy="48" rx="20" ry="14" class="o"/>
    <path d="M47 24 l -3 -10" class="o"/>
    <path d="M51 22 l -2 -12" class="o"/>
    <path d="M55 22 l  1 -11" class="o"/>
    <path d="M59 24 l  4 -10" class="o"/>
    <circle cx="57" cy="59" r="3" class="p"/>
    <circle cx="65" cy="61" r="3" class="p"/>
    <path d="M39 40 C  8 22,  8 52, 24 58" class="o"/>
    <path d="M37 48 C  6 42, 10 72, 28 73" class="o"/>
    <path d="M39 56 C  8 66, 12 90, 32 88" class="o"/>
    <path d="M59 40 C 90 22, 92 52, 76 58" class="o"/>
    <path d="M61 48 C 92 42, 90 72, 72 73" class="o"/>
    <path d="M59 56 C 90 66, 88 90, 68 88" class="o"/>
    <path d="M41 50 l -9 4" class="w"/>
    <path d="M41 46 l -9 -4" class="w"/>
    <circle cx="36" cy="58" r="2.2" class="f"/>
  </g>
</svg>`);

  const BossWidowImg = new Image();
  BossWidowImg.decoding = 'async';
  BossWidowImg.src = BOSS_BLACK_WIDOW_URI;
  const BW_FRAME_W = 128, BW_FRAME_H = 96;
  const BossWidowAnim = { last: 0, frame: 0, speedMs: 220 };
  function stepBossWidowAnim(now){ if (!BossWidowAnim.last) BossWidowAnim.last=now; if (now-BossWidowAnim.last>BossWidowAnim.speedMs){BossWidowAnim.last=now; BossWidowAnim.frame=(BossWidowAnim.frame+1)%2;} }
  function drawBossWidow(ctx, x, y, scale = 1){
    const sx = BossWidowAnim.frame * BW_FRAME_W;
    const dw = Math.round(BW_FRAME_W * scale);
    const dh = Math.round(BW_FRAME_H * scale);
    ctx.imageSmoothingEnabled = false;
    ctx.drawImage(BossWidowImg, sx, 0, BW_FRAME_W, BW_FRAME_H,
      Math.round(x - dw/2), Math.round(y - dh/2), dw, dh);
  }
  
  /*** SOUND SYSTEM ***/
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
  const sounds = {
    enabled: true,
    musicEnabled: true,
    sfx: {},
    music: null,
    ext: null,
    musicNode: null,
    musicGain: null
  };

  const AUDIO_PATH = 'assets/audio/';
  const SFX_PATH = AUDIO_PATH + 'sfx/';
  const MUSIC_PATH = AUDIO_PATH + 'music/';
  const SFX_FILES = {
    webDeploy: 'webDeploy',
    enemyKill: 'enemyKill',
    damage: 'damage',
    scorePoint: 'scorePoint',
    scoreCollect: 'scoreCollect',
    nuke: 'nuke',
    waveStart: 'waveStart',
    waveComplete: 'waveComplete',
    nukeCharged: 'nukeCharged',
    gameOver: 'gameOver',
    button: 'button',
    healthUp: 'healthUp'
  };
  const SFX_VOL = {
    webDeploy: 0.35,
    enemyKill: 0.4,
    damage: 0.5,
    scorePoint: 0.25,
    scoreCollect: 0.25,
    nuke: 0.5,
    waveStart: 0.3,
    waveComplete: 0.35,
    nukeCharged: 0.35,
    gameOver: 0.5,
    button: 0.2,
    healthUp: 0.4
  };

  function detectAudioExt(){
    const a = document.createElement('audio');
    if (a.canPlayType('audio/mpeg')) return '.mp3';
    if (a.canPlayType('audio/ogg')) return '.ogg';
    if (a.canPlayType('audio/wav')) return '.wav';
    return '.mp3';
  }

  function loadAllAudio(){
    sounds.ext = detectAudioExt();
    for (const [k, base] of Object.entries(SFX_FILES)){
      const el = new Audio(SFX_PATH + base + sounds.ext);
      el.preload = 'auto';
      el.volume = SFX_VOL[k] ?? 0.35;
      sounds.sfx[k] = el;
    }
  }

  // Resume audio context on user interaction (browser requirement)
  function resumeAudio() {
    if (audioCtx.state === 'suspended') {
      audioCtx.resume();
    }
  }

  // SFX player  uses folder assets/audio; falls back to synth if missing
  function playSound(type) {
    if (!sounds.enabled) return;
    if (!sounds.ext) loadAllAudio();
    // Try folder-based SFX first
    const base = sounds.sfx && sounds.sfx[type];
    if (base) {
      try{
        const a = base.cloneNode();
        a.volume = base.volume;
        a.play();
        return;
      }catch(e){/* fall back to synth */}
    }

    // Fallback: simple WebAudio beeps
    resumeAudio();
    const now = audioCtx.currentTime;
    const osc = audioCtx.createOscillator();
    const gain = audioCtx.createGain();
    osc.connect(gain);
    gain.connect(audioCtx.destination);
    switch(type) {
      case 'webDeploy': // Node placement
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(200, now + 0.1);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        osc.start(now);
        osc.stop(now + 0.15);
        break;
        
      case 'enemyKill': // Enemy destroyed
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.2);
        gain.gain.setValueAtTime(0.2, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        break;
        
      case 'damage': // Player takes damage
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(150, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.3);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.3);
        osc.start(now);
        osc.stop(now + 0.3);
        break;
        
      case 'scorePoint': // Score flies to board
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(1200, now + 0.08);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now);
        osc.stop(now + 0.1);
        break;
        
      case 'scoreCollect': // Score reaches board
        osc.frequency.setValueAtTime(1200, now);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
        break;
        
      case 'nuke': // Nuclear explosion
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(30, now + 0.5);
        gain.gain.setValueAtTime(0.3, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.6);
        osc.start(now);
        osc.stop(now + 0.6);
        // Add second layer
        const osc2 = audioCtx.createOscillator();
        const gain2 = audioCtx.createGain();
        osc2.connect(gain2);
        gain2.connect(audioCtx.destination);
        osc2.type = 'square';
        osc2.frequency.setValueAtTime(200, now);
        osc2.frequency.exponentialRampToValueAtTime(50, now + 0.4);
        gain2.gain.setValueAtTime(0.2, now);
        gain2.gain.exponentialRampToValueAtTime(0.01, now + 0.5);
        osc2.start(now);
        osc2.stop(now + 0.5);
        break;
        
      case 'waveStart': // New wave begins
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.exponentialRampToValueAtTime(500, now + 0.15);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now);
        osc.stop(now + 0.2);
        break;
        
      case 'waveComplete': // Wave cleared
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(800, now + 0.1);
        osc.frequency.exponentialRampToValueAtTime(1000, now + 0.2);
        gain.gain.setValueAtTime(0.15, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.25);
        osc.start(now);
        osc.stop(now + 0.25);
        break;
        
      case 'nukeCharged': // Nuke ready
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(900, now + 0.1);
        gain.gain.setValueAtTime(0.12, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.12);
        osc.start(now);
        osc.stop(now + 0.12);
        break;
        
      case 'gameOver': // Death
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.exponentialRampToValueAtTime(50, now + 0.8);
        gain.gain.setValueAtTime(0.25, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 1);
        osc.start(now);
        osc.stop(now + 1);
        break;
        
      case 'button': // UI button click
        osc.frequency.setValueAtTime(800, now);
        gain.gain.setValueAtTime(0.08, now);
        gain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        osc.start(now);
        osc.stop(now + 0.05);
        break;
    }
  }

  // Background music  loads from assets/audio/music/bg.(mp3|ogg|wav)
  function startMusic() {
    if (!sounds.musicEnabled) return;
    if (!sounds.ext) loadAllAudio();
    if (!sounds.music) {
      sounds.music = new Audio(MUSIC_PATH + 'bg' + (sounds.ext || '.mp3'));
      sounds.music.loop = true;
      sounds.music.volume = 0.25;
    }
    try{ sounds.music.play(); }catch(e){}
    sounds.musicNode = sounds.music;
  }

  function stopMusic() {
    if (sounds.music) { try{ sounds.music.pause(); sounds.music.currentTime = 0; }catch(e){} }
    sounds.musicNode = null;
  }

  // Sound toggle button
  const soundToggle = document.getElementById('soundToggle');
  soundToggle.addEventListener('click', () => {
    sounds.enabled = !sounds.enabled;
    sounds.musicEnabled = !sounds.musicEnabled;
    soundToggle.textContent = sounds.enabled ? 'SFX ON' : 'SFX OFF';
    if (sounds.musicEnabled && state.running) {
      startMusic();
    } else {
      stopMusic();
    }
    playSound('button');
  });

  /*** CANVAS ***/
  const canvas = document.getElementById('game');
  const gameContainer = document.getElementById('gameContainer');
  const ctx = canvas.getContext('2d', {alpha:false});
  let PIXEL_SCALE = (window.matchMedia && matchMedia('(max-width: 600px)').matches) ? 2 : 3;
  
  function resize(){ 
    const rect = gameContainer.getBoundingClientRect();
    canvas.width = Math.floor(rect.width / PIXEL_SCALE);
    canvas.height = Math.floor(rect.height / PIXEL_SCALE);
  }
  addEventListener('resize', resize, {passive:true}); 
  resize();
  ctx.imageSmoothingEnabled = false;

  const mq = (window.matchMedia && matchMedia('(max-width: 600px)'));
  if (mq) {
    const applyScale = () => { PIXEL_SCALE = mq.matches ? 2 : 3; resize(); };
    if (mq.addEventListener) mq.addEventListener('change', applyScale);
    else if (mq.addListener) mq.addListener(applyScale);
  }

  const elScore = document.getElementById('score');
  const elLives = document.getElementById('lives');
  const elSilk = document.getElementById('silk');
  const elCost = document.getElementById('cost');
  const elWave = document.getElementById('wave');
  const elSpeed = document.getElementById('speed');
  const restartBtn = document.getElementById('restart');
  const chargeBar = document.getElementById('chargeBar');
  const nukeBtn = document.getElementById('nukeBtn');
  const scorePill = document.getElementById('scorePill');
  const overlay = document.getElementById('overlay');
  const ovTitle = document.getElementById('ovTitle');
  const ovMsg = document.getElementById('ovMsg');
  const startBtn = document.getElementById('startBtn');
  const howBtn = document.getElementById('howBtn');
  const ovKeys = document.getElementById('ovKeys');
  const nukeBanner = document.getElementById('nukeBanner');

  const CENTER = () => ({x: canvas.width/2, y: canvas.height/2});
  const NEST_R = 10;
  const START_LIVES = 10, START_SILK = 50, SILK_MAX = 240, SILK_REGEN = 6;
  const NODE_COST = 15, NODE_R = 28, NODE_SLOW = 0.55, NODE_FADE = 0.35, NODE_DUR0 = 100, NODE_DECAY_PER_ENEMY = 7;
  const ENEMY_BASE = 8, ENEMY_HP0 = 10, ENEMY_SPEED0 = 0.025;
  const WAVE_GAP_MS = 7000, SPAWN_BURST = 260, SPEEDS = [1, 1.5, 2, 3], STUCK_KILL_MS = 2500;
  const NUKE_CHARGE_MAX = 100, NUKE_SCORE_PER_KILL = 8, NUKE_SILK_PER_KILL = 3;
  // Boss tuning
  const BOSS_SPEED = 0.018, BOSS_STUCK_MULT = 3.5, BOSS_SCORE = 50, BOSS_SILK = 40, BOSS_DAMAGE = 3;
  // Powerup (health bug)
  const POWERUP_HEAL = 2, POWERUP_SPEED = 0.02, POWERUP_INTERVAL_MS = 5000, POWERUP_CHANCE = 1.0;

  const COLORS = {
    bg:'#0c0602', grid:'#b56600', nest:'#ff8c00', nestCore:'#000',
    node:'#ff8c00', nodeDim:'#804400', web:'#ff8c0040', particle:'#00ff66'
  };

  const TYPES = [
    {key:'gnat',   name:'GNAT',   color:'#00e5ff', hp:ENEMY_HP0+0, speed:ENEMY_SPEED0*1.25, webResist:0.00, nukeImmune:false, stuckMult:1.0},
    {key:'beetle', name:'BEETLE', color:'#ffd000', hp:ENEMY_HP0+8, speed:ENEMY_SPEED0*0.85, webResist:0.60, nukeImmune:false, stuckMult:1.6},
    {key:'roach',  name:'ROACH',  color:'#ff7a00', hp:ENEMY_HP0+4, speed:ENEMY_SPEED0*1.00, webResist:0.20, nukeImmune:true, stuckMult:1.2},
    {key:'wasp',   name:'WASP',   color:'#ff3366', hp:ENEMY_HP0+6, speed:ENEMY_SPEED0*1.35, webResist:0.30, nukeImmune:false, stuckMult:1.1}
  ];

  function pickType(wave){
    const wGnat = Math.max(1, 6 - Math.floor(wave/3));
    const wBeet = Math.min(5, 1 + Math.floor(wave/4));
    const wRoach = Math.min(4, Math.floor(wave/5));
    const wWasp = Math.min(5, Math.floor(wave/3));
    const bag = [...Array(wGnat).fill('gnat'), ...Array(wBeet).fill('beetle'),
                 ...Array(wRoach).fill('roach'), ...Array(wWasp).fill('wasp')];
    const key = bag[Math.floor(Math.random()*bag.length)];
    return TYPES.find(t=>t.key===key) || TYPES[0];
  }

  const state = {
    running:false, t:0, dt:0, last:performance.now(),
    speedIndex:0, score:0, lives:START_LIVES, silk:START_SILK,
    wave:1, inWave:false, nextWaveAt:0, toSpawn:0, spawnTimer:0,
    enemies:[], nodes:[], particles:[], shots:[], powerups:[], powerupTimer:0,
    boss: null,
    spiderFlash:0 // flash timer for damage
  };
  state.nukeCharge = 0; state.nukeReady = false;

  function reset(full=true){
    state.running=false; state.t=0; state.dt=0; state.last=performance.now();
    state.speedIndex=0; state.score=0; state.lives=START_LIVES; state.silk=START_SILK;
    state.wave=1; state.inWave=false; state.nextWaveAt=0; state.toSpawn=0; state.spawnTimer=0;
    state.enemies.length=0; state.nodes.length=0; state.particles.length=0; state.shots.length=0; state.powerups.length=0; state.powerupTimer=0; state.shake=0;
    state.boss = null;
    state.nukeCharge=0; state.nukeReady=false; state.spiderFlash=0;
    if (full){
      elScore.textContent=state.score; elLives.textContent=state.lives;
      elSilk.textContent=Math.floor(state.silk); elCost.textContent=NODE_COST;
      elWave.textContent=state.wave; elSpeed.textContent=SPEEDS[state.speedIndex]+'x';
      chargeBar.style.width='0%'; nukeBtn.disabled=true;
    }
    if (nukeBanner) nukeBanner.style.display='none';
    stopMusic();
  }
  reset();

  function createFlyingScore(worldX, worldY, points) {
    const canvasRect = canvas.getBoundingClientRect();
    const screenX = canvasRect.left + (worldX / canvas.width) * canvasRect.width;
    const screenY = canvasRect.top + (worldY / canvas.height) * canvasRect.height;
    const scoreRect = scorePill.getBoundingClientRect();
    const targetX = scoreRect.left + scoreRect.width / 2;
    const targetY = scoreRect.top + scoreRect.height / 2;
    
    const scoreEl = document.createElement('div');
    scoreEl.className = 'flyingScore';
    scoreEl.textContent = '+' + points;
    scoreEl.style.left = screenX + 'px';
    scoreEl.style.top = screenY + 'px';
    document.body.appendChild(scoreEl);
    
    playSound('scorePoint'); // Sound when score launches
    
    const duration = 800, startTime = performance.now();
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime, progress = Math.min(elapsed / duration, 1);
      const eased = progress < 0.5 ? 2*progress*progress : 1-Math.pow(-2*progress+2,2)/2;
      const currentX = screenX + (targetX - screenX) * eased;
      const currentY = screenY + (targetY - screenY) * eased;
      scoreEl.style.left = currentX + 'px';
      scoreEl.style.top = currentY + 'px';
      scoreEl.style.opacity = (1 - progress * 0.3).toString();
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        scoreEl.remove();
        playSound('scoreCollect'); // Sound when score arrives
        scorePill.style.transform = 'scale(1.15)';
        scorePill.style.transition = 'transform 0.1s';
        setTimeout(() => { scorePill.style.transform = 'scale(1)'; }, 100);
      }
    };
    requestAnimationFrame(animate);
  }

  function canvasToWorld(ev){ 
    const r = canvas.getBoundingClientRect(); 
    return {x: (ev.clientX - r.left) * (canvas.width / r.width), y: (ev.clientY - r.top) * (canvas.height / r.height)}; 
  }
  
  canvas.addEventListener('pointerdown', e=>{
    if(!state.running) return; 
    const p=canvasToWorld(e); 
    placeNode(p.x,p.y);
  });
  
  addEventListener('keydown', e=>{
    if (e.key==='r'||e.key==='R'){playSound('button'); showOverlay('SPIDER STRIKE','SYSTEM REBOOT - REINFORCE NEST', true);}
    if (e.key==='+'){playSound('button'); changeSpeed(1);}
    if (e.key==='-'){playSound('button'); changeSpeed(-1);}
    if ((e.key==='n'||e.key==='N') && state.nukeReady){nuke();}
  });
  
  restartBtn.addEventListener('click',()=>{playSound('button'); showOverlay('SPIDER STRIKE','SYSTEM REBOOT - REINFORCE NEST', true);});
  nukeBtn.addEventListener('click', ()=>{if (state.nukeReady) nuke();});
  startBtn.addEventListener('click', ()=>{playSound('button'); overlay.style.display='none'; start();});
  howBtn.addEventListener('click', ()=>{
    playSound('button');
    ovTitle.textContent='[ INFO ]';
    ovMsg.innerHTML = `
      <b>GOAL:</b> PROTECT CENTER NEST<br>
      <b>NODES:</b> CLICK TO DEPLOY STICKY WEB<br>
      NODES WEAR DOWN AS ENEMIES PASS<br>
      <b>STUCK KILL:</b> SLOWED ENEMIES DIE AFTER ${(STUCK_KILL_MS/1000).toFixed(1)}S<br>
      <b>TYPES:</b> BEETLES RESIST WEBS<br>
      ROACHES IMMUNE TO NUKES<br>
      WASPS ARE FAST<br>
      <b>NUKE:</b> CHARGE BY SURVIVING WAVES
    `;
  });

  function showOverlay(title,msg,doReset=false){
    ovTitle.textContent=title; ovMsg.innerHTML=msg; overlay.style.display='grid'; state.running=false; if (ovKeys) ovKeys.style.display='flex'; if (doReset) reset();
  }
  
  function start(){
    reset(false); 
    state.running=true; 
    state.last=performance.now(); 
    state.nextWaveAt=state.t+800; 
    startMusic(); // Start background music
    requestAnimationFrame(loop);
  }
  
  function changeSpeed(d){state.speedIndex=Math.max(0,Math.min(SPEEDS.length-1,state.speedIndex+d)); elSpeed.textContent=SPEEDS[state.speedIndex]+'x';}

  function scheduleWave(){
    state.inWave=true; 
    state.toSpawn=Math.round(ENEMY_BASE+(state.wave-1)*3.5); 
    state.spawnTimer=0;
    playSound('waveStart'); // Wave start sound
  }

  function spawnBoss(){
    const side = Math.floor(Math.random()*4); let x,y;
    if (side===0){x=Math.random()*canvas.width; y=-20;}
    else if (side===1){x=canvas.width+20; y=Math.random()*canvas.height;}
    else if (side===2){x=Math.random()*canvas.width; y=canvas.height+20;}
    else {x=-20; y=Math.random()*canvas.height;}
    state.boss = { x, y, vx:0, vy:0, stuckTimer:0 };
    // Delay next wave until boss is defeated
    state.nextWaveAt = Number.POSITIVE_INFINITY;
  }
  
  function spawnEnemy(){
    const side = Math.floor(Math.random()*4); let x,y;
    if (side===0){x=Math.random()*canvas.width; y=-10;}
    else if (side===1){x=canvas.width+10; y=Math.random()*canvas.height;}
    else if (side===2){x=Math.random()*canvas.width; y=canvas.height+10;}
    else {x=-10; y=Math.random()*canvas.height;}
    const t = pickType(state.wave);
    const speed = (t.speed + 0.002*(state.wave-1)) * (0.9 + Math.random()*0.25);
    const hp = Math.round(t.hp + 0.6*(state.wave-1));
    state.enemies.push({x,y, hp, speed, slow:1, stuckTimer:0, type:t, stun:0, vx:0, vy:0});
  }

  function drawPowerupSprite(ctx, p, scale = 0.56) {
    const img = EnemySprites['medic'];
    if (!img || !img.complete) {
      ctx.save();
      ctx.fillStyle = '#1b1b22';
      ctx.strokeStyle = '#ff3344';
      ctx.lineWidth = 1.5;
      ctx.beginPath();
      ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
      ctx.fill();
      ctx.stroke();
      ctx.restore();
      return;
    }
    const sx = EnemyAnim.frame * EnemyAnim.w;
    const sy = 0;
    const dw = EnemyAnim.w * scale;
    const dh = EnemyAnim.h * scale;
    ctx.drawImage(
      img, sx, sy, EnemyAnim.w, EnemyAnim.h,
      Math.round(p.x - dw/2), Math.round(p.y - dh/2),
      Math.round(dw), Math.round(dh)
    );
  }

  function spawnPowerup(){
    // Spawn from a random edge and drift; does NOT home to spider
    const side = Math.floor(Math.random()*4); let x,y;
    if (side===0){x=Math.random()*canvas.width; y=-10;}
    else if (side===1){x=canvas.width+10; y=Math.random()*canvas.height;}
    else if (side===2){x=Math.random()*canvas.width; y=canvas.height+10;}
    else {x=-10; y=Math.random()*canvas.height;}
    const a = Math.random()*Math.PI*2;
    state.powerups.push({x,y, speed:POWERUP_SPEED, vx:Math.cos(a)*POWERUP_SPEED, vy:Math.sin(a)*POWERUP_SPEED});
  }

  function placeNode(x,y){
    if (state.silk < NODE_COST) return;
    const c = CENTER(); const d = Math.hypot(x-c.x, y-c.y);
    if (d < NEST_R + 10) return;
    state.silk = Math.max(0, state.silk - NODE_COST); elSilk.textContent=Math.floor(state.silk);
    // Fire a web shot from center to target; node spawns on impact
    state.shots.push({ x:c.x, y:c.y, tx:x, ty:y, speed:0.40 });
    state.shake = 2;
    playSound('button'); // firing cue; deploy sound on impact
  }

  function addScore(n, worldX, worldY){ 
    state.score += n; 
    elScore.textContent = state.score;
    if (worldX !== undefined && worldY !== undefined) {
      createFlyingScore(worldX, worldY, n);
    }
  }
  
  function damage(n){ 
    state.lives -= n; 
    elLives.textContent=Math.max(0,state.lives); 
    state.shake = 8;
    state.spiderFlash = 300; // Flash spider for 300ms
    playSound('damage'); // Damage sound
    if(state.lives<=0) gameOver(); 
  }

  const particles = state.particles;
  function emitBurst(x,y, baseColor, count=12){
    for (let i=0;i<count;i++){
      const a = Math.random()*Math.PI*2, sp = 0.5 + Math.random()*1.8;
      particles.push({x,y, vx: Math.cos(a)*sp, vy: Math.sin(a)*sp, life: 0, max: 280 + Math.random()*200,
        size: 1 + Math.random()*2, color: baseColor || COLORS.particle});
    }
  }
  function updateParticles(dt){
    for (let i=particles.length-1;i>=0;i--){
      const p=particles[i]; p.life += dt; p.x += p.vx*dt*0.06; p.y += p.vy*dt*0.06;
      p.vx *= 0.99; p.vy *= 0.99;
      if (p.life >= p.max) particles.splice(i,1);
    }
  }

  function updatePowerups(dt){
    for (let i = state.powerups.length - 1; i >= 0; i--) {
      const p = state.powerups[i];
      p.x += p.vx * dt; p.y += p.vy * dt;
      // Bounce at edges
      if (p.x < 2){ p.x = 2; p.vx = Math.abs(p.vx); }
      if (p.x > canvas.width-2){ p.x = canvas.width-2; p.vx = -Math.abs(p.vx); }
      if (p.y < 2){ p.y = 2; p.vy = Math.abs(p.vy); }
      if (p.y > canvas.height-2){ p.y = canvas.height-2; p.vy = -Math.abs(p.vy); }
    }
  }

  function updateShots(dt){
    const shots = state.shots;
    for (let i = shots.length - 1; i >= 0; i--) {
      const s = shots[i];
      const vx = s.tx - s.x, vy = s.ty - s.y; const dist = Math.hypot(vx, vy) || 1;
      const step = s.speed * dt; // pixels per ms
      if (dist <= step + 1) {
        // Impact: spawn node, small burst, sound
        state.nodes.push({ x: s.tx, y: s.ty, r: NODE_R, t: state.t, dur: NODE_DUR0 });
        emitBurst(s.tx, s.ty, COLORS.node, 10);
        // Check for powerup hit (must shoot it)
        const CAPTURE_R = 18;
        for (let j = state.powerups.length - 1; j >= 0; j--) {
          const p = state.powerups[j];
          if (Math.hypot(p.x - s.tx, p.y - s.ty) <= CAPTURE_R) {
            state.powerups.splice(j,1);
            state.lives += POWERUP_HEAL; elLives.textContent = Math.max(0,state.lives);
            emitBurst(s.tx, s.ty, '#ff3366', 22);
            playSound('healthUp');
          }
        }
                // Direct enemy hit: kill and heal like powerup
        let healed = 0;
        for (let k = state.enemies.length - 1; k >= 0; k--) {
          const e = state.enemies[k];
          if (Math.hypot(e.x - s.tx, e.y - s.ty) <= CAPTURE_R) {
            state.enemies.splice(k, 1);
            healed += POWERUP_HEAL;
            addScore(6, e.x, e.y);
            emitBurst(e.x, e.y, '#ff3366', 22);
          }
        }
        if (healed > 0) {
          state.lives += healed; elLives.textContent = Math.max(0, state.lives);
          playSound('healthUp');
        }        playSound('webDeploy');
        shots.splice(i, 1);
        continue;
      }
      const ux = vx / dist, uy = vy / dist;
      s.x += ux * step; s.y += uy * step;
    }
  }
  function drawParticles(){
    for (const p of particles){
      const a = 1 - (p.life / p.max);
      ctx.globalAlpha = Math.max(0, a);
      ctx.fillStyle = p.color;
      const s = Math.ceil(p.size);
      ctx.fillRect(Math.floor(p.x), Math.floor(p.y), s, s);
      ctx.globalAlpha = 1;
    }
  }

  function nuke(){
    const center = CENTER();
    let killed = 0;
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];
      if (false) { }
      emitBurst(e.x, e.y, (e.type && e.type.color) || COLORS.particle, 28);
      createFlyingScore(e.x, e.y, NUKE_SCORE_PER_KILL);
      state.enemies.splice(i,1); killed++;
    }
    if (killed>0){
      state.score += killed * NUKE_SCORE_PER_KILL;
      elScore.textContent = state.score;
      state.silk = Math.min(SILK_MAX, state.silk + killed * NUKE_SILK_PER_KILL);
      elSilk.textContent = Math.floor(state.silk);
    }
    state.nukeCharge = 0; state.nukeReady=false; chargeBar.style.width='0%'; nukeBtn.disabled=true;
    if (nukeBanner) nukeBanner.style.display='none';
    state.shake = 15;
    playSound('nuke'); // Nuke explosion sound

    const start = performance.now(), dur = 400;
    const flashAnim = (t)=>{
      const p=(t-start)/dur; if (p>=1) return;
      ctx.save(); ctx.globalAlpha = (1-p) * 0.4;
      ctx.fillStyle='#ff8c00';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      ctx.restore();
      requestAnimationFrame(flashAnim);
    };
    requestAnimationFrame(flashAnim);
  }

  function loop(now){
    if (!state.running) return;
    requestAnimationFrame(loop);

    const baseDt = now - state.last; state.last = now;
    const dt = baseDt * SPEEDS[state.speedIndex];
    state.dt = dt; state.t += dt;

    if (state.shake > 0) state.shake = Math.max(0, state.shake - dt * 0.03);
    if (state.spiderFlash > 0) state.spiderFlash = Math.max(0, state.spiderFlash - dt);

    updateShots(dt);
    updatePowerups(dt);

    state.silk = Math.min(SILK_MAX, state.silk + SILK_REGEN * (dt/1000)); elSilk.textContent=Math.floor(state.silk);

    if (!state.inWave && state.t >= state.nextWaveAt) scheduleWave();
    if (state.inWave && state.toSpawn > 0){
      state.spawnTimer += dt;
      while (state.spawnTimer > SPAWN_BURST && state.toSpawn > 0){
        state.spawnTimer -= SPAWN_BURST; spawnEnemy(); state.toSpawn--;
      }
    }
    if (state.inWave && state.toSpawn<=0 && state.enemies.length===0){
      state.inWave=false; 
      state.wave++; 
      elWave.textContent=state.wave; 
      state.silk = Math.min(SILK_MAX, state.silk + 20 + 5*state.wave);
      state.nukeCharge = Math.min(NUKE_CHARGE_MAX, state.nukeCharge + 28);
      playSound('waveComplete'); // Wave complete sound
      if (state.wave % 3 === 0) {
        spawnBoss();
      } else {
        state.nextWaveAt = state.t + WAVE_GAP_MS;
        if (Math.random() < POWERUP_CHANCE) spawnPowerup();
      }
    }

    // Frequent powerup spawns while running
    state.powerupTimer += dt;
    if (state.powerupTimer >= POWERUP_INTERVAL_MS) {
      if (state.powerups.length < 5) spawnPowerup();
      state.powerupTimer = 0;
    }
    
    const prevCharge = state.nukeCharge;
    state.nukeCharge = Math.min(NUKE_CHARGE_MAX, state.nukeCharge + 0.008 * (dt/16));
    chargeBar.style.width = (state.nukeCharge/NUKE_CHARGE_MAX*100).toFixed(1) + '%';
    
    if (state.nukeCharge >= NUKE_CHARGE_MAX && !state.nukeReady){
      state.nukeReady=true; 
      nukeBtn.disabled=false;
      playSound('nukeCharged'); // Nuke charged sound
      if (nukeBanner) nukeBanner.style.display='block';
    }

    const c = CENTER();
    for (let i=state.enemies.length-1;i>=0;i--){
      const e = state.enemies[i];

      let slow = 1, heavySlow = false;
      for (const n of state.nodes){
        const dx=e.x-n.x, dy=e.y-n.y; const d=Math.hypot(dx,dy);
        if (d < n.r){
          const t = 1 - (d/n.r);
          const s = 1 - (NODE_FADE + (NODE_SLOW - NODE_FADE) * t);
          slow *= s;
          if (t > 0.55) heavySlow = true;
          n.dur -= NODE_DECAY_PER_ENEMY * (dt/1000) * (0.35 + 0.65*t);
        }
      }
      slow = slow + (1 - slow) * (e.type.webResist || 0);
      slow = Math.min(1, Math.max(0.12, slow));

      const need = STUCK_KILL_MS * (e.type.stuckMult || 1);
      if (slow < 0.75 && heavySlow) e.stuckTimer = (e.stuckTimer||0) + dt; else e.stuckTimer = Math.max(0,(e.stuckTimer||0) - dt*1.5);
      if (e.stuckTimer >= need){
        emitBurst(e.x, e.y, '#00ff66', 14);
        addScore(6, e.x, e.y);
        state.silk = Math.min(SILK_MAX, state.silk + 2); elSilk.textContent=Math.floor(state.silk);
        state.shake = 2;
        playSound('enemyKill'); // Enemy kill sound
        state.enemies.splice(i,1); continue;
      }

      if (e.stun>0){
        e.stun -= dt;
        e.vx = (e.vx||0) * 0.92;
        e.vy = (e.vy||0) * 0.92;
      } else {
        const dx = c.x - e.x, dy = c.y - e.y; const dist = Math.hypot(dx,dy)||1;
        const ux = dx / dist, uy = dy / dist;
        const desired = e.speed * slow; // px/ms
        const alpha = 1 - Math.exp(-dt * 0.02); // smoothing factor 0..1
        e.vx = (e.vx||0) + (ux*desired - (e.vx||0)) * alpha;
        e.vy = (e.vy||0) + (uy*desired - (e.vy||0)) * alpha;
        e.x += e.vx * dt; e.y += e.vy * dt;
        const nd = Math.hypot(c.x - e.x, c.y - e.y);
        if (nd <= NEST_R){state.enemies.splice(i,1); damage(1); continue;}
      }
    }

    // Boss update
    if (state.boss) {
      let slow = 1, heavySlow = false;
      for (const n of state.nodes){
        const dx=state.boss.x-n.x, dy=state.boss.y-n.y; const d=Math.hypot(dx,dy);
        if (d < n.r){
          const t = 1 - (d/n.r);
          const s = 1 - (NODE_FADE + (NODE_SLOW - NODE_FADE) * t);
          slow *= s;
          if (t > 0.55) heavySlow = true;
          n.dur -= NODE_DECAY_PER_ENEMY * 1.25 * (dt/1000) * (0.35 + 0.65*t); // boss strains webs
        }
      }
      slow = Math.min(1, Math.max(0.08, slow));
      const need = STUCK_KILL_MS * BOSS_STUCK_MULT;
      if (slow < 0.70 && heavySlow) state.boss.stuckTimer = (state.boss.stuckTimer||0) + dt; else state.boss.stuckTimer = Math.max(0,(state.boss.stuckTimer||0) - dt*1.2);
      if (state.boss.stuckTimer >= need){
        emitBurst(state.boss.x, state.boss.y, '#ff2136', 36);
        addScore(BOSS_SCORE, state.boss.x, state.boss.y);
        state.silk = Math.min(SILK_MAX, state.silk + BOSS_SILK); elSilk.textContent=Math.floor(state.silk);
        state.shake = 8;
        state.boss = null;
        state.nextWaveAt = state.t + WAVE_GAP_MS; // resume waves
      } else {
        const dx = c.x - state.boss.x, dy = c.y - state.boss.y; const dist = Math.hypot(dx,dy)||1;
        const ux = dx / dist, uy = dy / dist;
        const desired = BOSS_SPEED * slow;
        const alpha = 1 - Math.exp(-dt * 0.02);
        state.boss.vx = (state.boss.vx||0) + (ux*desired - (state.boss.vx||0)) * alpha;
        state.boss.vy = (state.boss.vy||0) + (uy*desired - (state.boss.vy||0)) * alpha;
        state.boss.x += state.boss.vx * dt; state.boss.y += state.boss.vy * dt;
        const nd = Math.hypot(c.x - state.boss.x, c.y - state.boss.y);
        if (nd <= NEST_R){ state.boss = null; damage(BOSS_DAMAGE); state.nextWaveAt = state.t + WAVE_GAP_MS; }
      }
    }

    for (let i=state.nodes.length-1;i>=0;i--){if (state.nodes[i].dur <= 0) state.nodes.splice(i,1);}

    updateParticles(dt);
    render();
  }

  function render(){
    ctx.save();
    
    if (state.shake > 0) {
      const sx = (Math.random() - 0.5) * state.shake;
      const sy = (Math.random() - 0.5) * state.shake;
      ctx.translate(sx, sy);
    }

    // Advance enemy animation
    stepEnemyAnim(performance.now());

    ctx.fillStyle = COLORS.bg;
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Pixelated spiderweb background
    {
      const c = CENTER();
      ctx.globalAlpha = 0.35;
      // Concentric rings
      const maxR = Math.max(
        Math.hypot(c.x, c.y),
        Math.hypot(canvas.width - c.x, c.y),
        Math.hypot(c.x, canvas.height - c.y),
        Math.hypot(canvas.width - c.x, canvas.height - c.y)
      );
      ctx.lineWidth = 1;
      for (let r = 16; r < maxR; r += 16) {
        drawPixelCircle(Math.floor(c.x), Math.floor(c.y), Math.floor(r), COLORS.grid, true);
      }

      // Radial lines
      const radials = 16;
      for (let i = 0; i < radials; i++) {
        const a = (i / radials) * Math.PI * 2;
        const x1 = Math.floor(c.x + Math.cos(a) * (maxR + 8));
        const y1 = Math.floor(c.y + Math.sin(a) * (maxR + 8));
        drawPixelLine(Math.floor(c.x), Math.floor(c.y), x1, y1, COLORS.grid);
      }
      ctx.globalAlpha = 1;
    }

    const c = CENTER();

    // Draw web shots (strand + head)
    for (const s of state.shots) {
      const strandColor = '#ffe9cc';
      // anchor from current center to shot head for an elastic strand feel
      drawPixelLine(Math.floor(c.x), Math.floor(c.y), Math.floor(s.x), Math.floor(s.y), strandColor);
      // slight thickness by offset
      drawPixelLine(Math.floor(c.x+1), Math.floor(c.y), Math.floor(s.x+1), Math.floor(s.y), strandColor);
      // head
      ctx.fillStyle = strandColor;
      ctx.fillRect(Math.floor(s.x)-1, Math.floor(s.y)-1, 2, 2);
    }

    for (const n of state.nodes) {
      const steps = 8;
      for (let i = steps; i > 0; i--) {
        const a = (i / steps) * 0.25;
        ctx.globalAlpha = a;
        ctx.fillStyle = COLORS.web;
        const r = (n.r / steps) * i;
        drawPixelCircle(n.x, n.y, r, COLORS.web);
      }
      ctx.globalAlpha = 1;

      // Pixelated cobweb texture overlay (radials + rings)
      {
        const webColor = '#ffe9cc';
        ctx.globalAlpha = 0.35;
        const radials = 12;
        for (let i = 0; i < radials; i++){
          const a = (i / radials) * Math.PI * 2;
          const ex = Math.floor(n.x + Math.cos(a) * n.r);
          const ey = Math.floor(n.y + Math.sin(a) * n.r);
          drawPixelLine(Math.floor(n.x), Math.floor(n.y), ex, ey, webColor);
        }
        for (let rr = 6; rr < n.r; rr += 6){
          drawPixelRing(Math.floor(n.x), Math.floor(n.y), Math.floor(rr), webColor, 24);
        }
        ctx.globalAlpha = 1;
      }

      const coreSize = 4;
      ctx.fillStyle = COLORS.nodeDim;
      ctx.fillRect(Math.floor(n.x - coreSize/2), Math.floor(n.y - coreSize/2), coreSize, coreSize);
      
      const p = Math.max(0, Math.min(1, n.dur / NODE_DUR0));
      ctx.fillStyle = p > 0.5 ? '#ff8c00' : (p > 0.25 ? '#ffb84d' : '#cc5500');
      const durSize = Math.ceil(p * 3);
      if (durSize > 0) {
        ctx.fillRect(Math.floor(n.x - 1), Math.floor(n.y - 6), durSize, 1);
      }
    }

    drawParticles();

    // Draw powerups
    for (const p of state.powerups) {
      drawPowerupSprite(ctx, p, 0.56);
    }

    // Draw enemies with animated sprites
    for (const e of state.enemies) {
      // Draw sprite
      const scale = SCALE_BY_TYPE[e.type.key] || 0.30;
      drawEnemySprite(ctx, e, scale);
      
      // Stuck indicator (drawn after sprite)
      if (e.stuckTimer && e.stuckTimer > 0) {
        const need = STUCK_KILL_MS * (e.type.stuckMult || 1);
        const p = Math.min(1, e.stuckTimer / need);
        ctx.fillStyle = '#ff8c00';
        const ring = Math.floor(6 + p * 3);
        drawPixelCircle(e.x, e.y, ring, '#ff8c00', true);
      }
      
      // Stun indicator (drawn after sprite)
      if (e.stun > 0) {
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 1;
        drawPixelCircle(e.x, e.y, 8, '#ffffff', true);
      }
    }

    // Draw boss
    if (state.boss) {
      stepBossWidowAnim(performance.now());
      drawBossWidow(ctx, state.boss.x, state.boss.y, 0.7);
      if (state.boss.stuckTimer && state.boss.stuckTimer > 0) {
        const need = STUCK_KILL_MS * BOSS_STUCK_MULT;
        const p = Math.min(1, state.boss.stuckTimer / need);
        const ring = Math.floor(10 + p * 6);
        drawPixelCircle(state.boss.x, state.boss.y, ring, '#ff2136', true);
      }
    }

    // Nest - chunky pixel art - ALWAYS IN CENTER
    // Remove outer circle glow - only keep nest body and outline
    
    // Nest body
    ctx.fillStyle = COLORS.nestCore;
    drawPixelCircle(c.x, c.y, NEST_R, COLORS.nestCore, false);
    
    // Nest outline
    ctx.strokeStyle = COLORS.nest;
    ctx.lineWidth = 2;
    drawPixelCircle(c.x, c.y, NEST_R, COLORS.nest, true);
    
    // Animated spider sprite in center - DOUBLED SIZE
    ctx.save();
    drawSpiderSprite(ctx, c.x, c.y, 0.6); // Scale 0.6 for double size
    
    // Flash effect when damaged
    if (state.spiderFlash > 0) {
      flashSpider(ctx, c.x, c.y, 0.6); // Match doubled size
    }
    ctx.restore();

    ctx.restore();
  }

  function drawPixelCircle(cx, cy, r, color, outlineOnly = false) {
    if (outlineOnly) {
      ctx.strokeStyle = color;
      const points = [];
      for (let a = 0; a < Math.PI * 2; a += Math.PI / 16) {
        points.push({x: Math.floor(cx + Math.cos(a) * r), y: Math.floor(cy + Math.sin(a) * r)});
      }
      for (let i = 0; i < points.length; i++) {
        const p1 = points[i];
        const p2 = points[(i + 1) % points.length];
        ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y); ctx.stroke();
      }
    } else {
      ctx.fillStyle = color;
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI * 2); ctx.fill();
    }
  }

  function drawPixelLine(x0, y0, x1, y1, color) {
    let x = Math.floor(x0), y = Math.floor(y0);
    const tx = Math.floor(x1), ty = Math.floor(y1);
    const dx = Math.abs(tx - x), dy = Math.abs(ty - y);
    const sx = x < tx ? 1 : -1;
    const sy = y < ty ? 1 : -1;
    let err = dx - dy;
    ctx.fillStyle = color;
    while (true) {
      ctx.fillRect(x, y, 1, 1);
      if (x === tx && y === ty) break;
      const e2 = err * 2;
      if (e2 > -dy) { err -= dy; x += sx; }
      if (e2 < dx) { err += dx; y += sy; }
    }
  }

  function drawPixelRing(cx, cy, r, color, segments = 24){
    const pts = [];
    for (let i = 0; i < segments; i++){
      const a = (i / segments) * Math.PI * 2;
      pts.push({ x: Math.floor(cx + Math.cos(a) * r), y: Math.floor(cy + Math.sin(a) * r) });
    }
    for (let i = 0; i < pts.length; i++){
      const p1 = pts[i], p2 = pts[(i+1)%pts.length];
      drawPixelLine(p1.x, p1.y, p2.x, p2.y, color);
    }
  }

  function gameOver(){
    state.running=false; 
    overlay.style.display='grid';
    ovTitle.textContent='GAME OVER';
    ovMsg.innerHTML = `FINAL SCORE: <b>${state.score}</b><br>WAVE: <b>${state.wave}</b><br><br>NEST DESTROYED`;
    startBtn.textContent='? RETRY';
    if (ovKeys) ovKeys.style.display='none';
    playSound('gameOver'); // Game over sound
    stopMusic(); // Stop background music
  }

  window.__SPIDER_NUKE = nuke;
  overlay.style.display='grid';
})();
</script>
</body>
</html>
